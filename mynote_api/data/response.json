{
  "docs": [
    {
      "id": "e1a7bb0f-2f75-4b2b-bcdd-afbbde9128ed",
      "emoji": null,
      "title": "Получить одно поле",
      "content": "",
      "headId": 1558974,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Поля",
      "parentFolderId": "22f60f22-d084-4786-9b11-dd65eac7421b",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T14:11:50.486Z",
      "updatedAt": "2021-11-22T14:13:05.808Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558974,
        "docId": "e1a7bb0f-2f75-4b2b-bcdd-afbbde9128ed",
        "content": "Пример кода \n\n``` js\nconst SiteClient = require('datocms-client').SiteClient;\nconst client = new SiteClient('YOUR-API-TOKEN');\nconst fieldIdOrApiKey = 'blog_post::title';\nclient.field.find(fieldIdOrApiKey)\n.then((field) => {\n  console.log(field);\n})\n.catch((error) => {\n  console.error(error);\n});\n\n```\n\n``` json\n{\n  \"id\": \"124\",\n  \"label\": \"Title\",\n  \"fieldType\": \"string\",\n  \"localized\": true,\n  \"defaultValue\": {\n    \"en\": \"A default value\",\n    \"it\": \"Un valore di default\"\n  },\n  \"apiKey\": \"title\",\n  \"hint\": \"This field will be used as post title\",\n  \"validators\": {\n    \"required\": {}\n  },\n  \"appearance\": {\n    \"editor\": \"single_line\",\n    \"parameters\": {\n      \"heading\": false\n    },\n    \"addons\": [\n      {\n        \"id\": \"1234\",\n        \"parameters\": {}\n      }\n    ]\n  },\n  \"position\": 1,\n  \"itemType\": \"44\",\n  \"fieldset\": null\n}\n```",
        "message": "",
        "created": "2021-11-22T14:13:05.797Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "213d3881-96c5-4e02-a725-422999be16ae",
      "emoji": null,
      "title": "Получить все поля",
      "content": "",
      "headId": 1558964,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Поля",
      "parentFolderId": "22f60f22-d084-4786-9b11-dd65eac7421b",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T14:10:35.059Z",
      "updatedAt": "2021-11-22T14:11:53.357Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558964,
        "docId": "213d3881-96c5-4e02-a725-422999be16ae",
        "content": "Возвращает массив объектов поля .\n\nПример кода \n\n``` js\nconst SiteClient = require('datocms-client').SiteClient;\nconst client = new SiteClient('YOUR-API-TOKEN');\nconst modelIdOrApiKey = 'blog_post';\nclient.fields.all(modelIdOrApiKey)\n.then((fields) => {\n    fields.forEach((field) => {\n      console.log(field);\n    });\n  })\n.catch((error) => {\n  console.error(error);\n});\n\n```\n\nВозвращает \n\n``` json\n{\n  \"id\": \"124\",\n  \"label\": \"Title\",\n  \"fieldType\": \"string\",\n  \"localized\": true,\n  \"defaultValue\": {\n    \"en\": \"A default value\",\n    \"it\": \"Un valore di default\"\n  },\n  \"apiKey\": \"title\",\n  \"hint\": \"This field will be used as post title\",\n  \"validators\": {\n    \"required\": {}\n  },\n  \"appearance\": {\n    \"editor\": \"single_line\",\n    \"parameters\": {\n      \"heading\": false\n    },\n    \"addons\": [\n      {\n        \"id\": \"1234\",\n        \"parameters\": {}\n      }\n    ]\n  },\n  \"position\": 1,\n  \"itemType\": \"44\",\n  \"fieldset\": null\n}\n```",
        "message": "",
        "created": "2021-11-22T14:11:53.336Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "0b684ca1-a0a9-4bf1-a266-6aeb98c14732",
      "emoji": null,
      "title": "Поля",
      "content": "",
      "headId": 1558956,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Поля",
      "parentFolderId": "22f60f22-d084-4786-9b11-dd65eac7421b",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T14:09:33.491Z",
      "updatedAt": "2021-11-22T14:10:34.339Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558956,
        "docId": "0b684ca1-a0a9-4bf1-a266-6aeb98c14732",
        "content": "Каждая модель состоит из набора полей. Использование в метафоре базы данных, поля как столбцы таблицы, и при их создании необходимо указать их тип ( string, file, floatи т.д.) и любую необходимую проверку.",
        "message": "",
        "created": "2021-11-22T14:10:34.315Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "3cee762d-313e-43a5-ae10-2bee9193d008",
      "emoji": null,
      "title": "Получить одну модель",
      "content": "",
      "headId": 1558941,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Модели",
      "parentFolderId": "564f5378-39fc-4711-8cc5-d8328d997a2d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T14:07:52.393Z",
      "updatedAt": "2021-11-22T14:09:29.862Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558941,
        "docId": "3cee762d-313e-43a5-ae10-2bee9193d008",
        "content": "Пример кода \n\n``` js\nconst SiteClient = require('datocms-client').SiteClient;\nconst client = new SiteClient('YOUR-API-TOKEN');\nconst modelIdOrApiKey = 'blog_post';\nclient.itemType.find(modelIdOrApiKey)\n.then((itemType) => {\n  console.log(itemType);\n})\n.catch((error) => {\n  console.error(error);\n});\n\n```\n\nВозвращает \n\n``` json\n{\n  \"id\": \"44\",\n  \"name\": \"Blog post\",\n  \"apiKey\": \"post\",\n  \"collectionAppearance\": \"compact\",\n  \"singleton\": false,\n  \"allLocalesRequired\": false,\n  \"sortable\": true,\n  \"modularBlock\": false,\n  \"draftModeActive\": false,\n  \"tree\": false,\n  \"orderingDirection\": null,\n  \"orderingMeta\": \"created_at\",\n  \"hasSingletonItem\": false,\n  \"hint\": \"Blog posts will be shown in our website under the Blog section\",\n  \"singletonItem\": null,\n  \"fields\": [\n    \"124\"\n  ],\n  \"titleField\": null,\n  \"orderingField\": null,\n  \"workflow\": null\n}\n```",
        "message": "",
        "created": "2021-11-22T14:09:29.854Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "aafe158c-a8eb-4d8a-8ada-f24547076641",
      "emoji": null,
      "title": "Получить одну запись",
      "content": "",
      "headId": 1558931,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Записи",
      "parentFolderId": "53097202-17bf-45fb-a544-29dbe00d16ef",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T14:03:15.155Z",
      "updatedAt": "2021-11-22T14:07:55.783Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558931,
        "docId": "aafe158c-a8eb-4d8a-8ada-f24547076641",
        "content": "# Параметры запроса\n- __nested__ - Для полей модульного содержимого и полей структурированного текста. Если установлено, возвращает полную полезную нагрузку для вложенных блоков вместо идентификаторов.\n- __version__ - Позволяет указать какую версию контента получить: published по умолчанию или current\n\nПример кода \n\n``` js\nconst SiteClient = require('datocms-client').SiteClient;\nconst client = new SiteClient('YOUR-API-TOKEN');\nconst itemId = '4235';\nclient.item.find(itemId, {\n  nested: 'true',\n  version: 'published'\n})\n.then((item) => {\n  console.log(item);\n})\n.catch((error) => {\n  console.error(error);\n});\n\n```\n\nВозвращает \n\n``` json\n{\n  \"id\": \"4235\",\n  \"title\": \"My first blog post!\",\n  \"content\": \"Lorem ipsum dolor sit amet...\",\n  \"category\": \"24\",\n  \"image\": {\n    \"alt\": \"Alt text\",\n    \"title\": \"Image title\",\n    \"customData\": {},\n    \"focalPoint\": null,\n    \"uploadId\": \"20042921\"\n  },\n  \"meta\": {\n    \"created_at\": \"2020-04-21T07:57:11.124Z\",\n    \"updated_at\": \"2020-04-21T07:57:11.124Z\",\n    \"published_at\": \"2020-04-21T07:57:11.124Z\",\n    \"first_published_at\": \"2020-04-21T07:57:11.124Z\",\n    \"publication_scheduled_at\": \"2020-04-21T07:57:11.124Z\",\n    \"unpublishing_scheduled_at\": \"2020-04-21T07:57:11.124Z\",\n    \"status\": \"draft\",\n    \"is_valid\": true,\n    \"current_version\": \"4234\",\n    \"stage\": \"\"\n  },\n  \"itemType\": \"44\",\n  \"creator\": \"312\"\n}\n```",
        "message": "",
        "created": "2021-11-22T14:07:55.775Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "25c153d4-cdc9-4127-a18f-ade226bdea07",
      "emoji": null,
      "title": "Получить все модели",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Модели",
      "parentFolderId": "564f5378-39fc-4711-8cc5-d8328d997a2d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T13:20:06.478Z",
      "updatedAt": "2021-11-22T13:20:06.478Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": null
    },
    {
      "id": "67f0d96d-ffec-43d3-9379-fa9b5afb2748",
      "emoji": null,
      "title": "Модели",
      "content": "",
      "headId": 1558718,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Модели",
      "parentFolderId": "564f5378-39fc-4711-8cc5-d8328d997a2d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T13:06:37.272Z",
      "updatedAt": "2021-11-22T13:07:34.996Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558718,
        "docId": "67f0d96d-ffec-43d3-9379-fa9b5afb2748",
        "content": "Если записи это строки в таблице DatoCMS то модели это таблицы.",
        "message": "",
        "created": "2021-11-22T13:07:34.967Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "e16a6fb1-84a0-452b-8ea1-0e478a447366",
      "emoji": null,
      "title": "Записи",
      "content": "",
      "headId": 1558631,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Записи",
      "parentFolderId": "53097202-17bf-45fb-a544-29dbe00d16ef",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T12:48:14.623Z",
      "updatedAt": "2021-11-22T12:48:22.264Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558631,
        "docId": "e16a6fb1-84a0-452b-8ea1-0e478a447366",
        "content": "DatoCMS хранит отдельные фрагменты контента, которые вы создаете из модели, в виде записей, которые очень похожи на строки таблицы в базе данных. По причинам обратной совместимости API называет записи «элементами».",
        "message": "",
        "created": "2021-11-22T12:48:22.254Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "ef622071-87bb-4256-8a3c-7eec68351bcb",
      "emoji": null,
      "title": "Получить все записи",
      "content": "",
      "headId": 1558677,
      "archivedAt": null,
      "folderPathname": "/DatoCMS/Записи",
      "parentFolderId": "53097202-17bf-45fb-a544-29dbe00d16ef",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T11:53:57.575Z",
      "updatedAt": "2021-11-22T13:00:58.558Z",
      "version": 13,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558677,
        "docId": "ef622071-87bb-4256-8a3c-7eec68351bcb",
        "content": "Что бы получить все записи нам нужен метод __all()__. Который имеет следующие параметры запроса. \n\n- __nested__ - Для полей модульного содержимого и полей структурированного текста. Если установлено, возвращает полную полезную нагрузку для вложенных блоков вместо идентификаторов. _Пока не совсем понял как оно работает_.\n- __filter__ - Это объект который принимает в себя различные критерие фильтрации такие как:\n  - __ids__ - Поиск по диапазону id-шников котрый указываеться через запятую,  Если вы используете этот фильтр, вы не должны использовать __filter[type]__ или __filter[fields]__.\n  - __type__ - Поиск по __idModels__ или __api_key__. Если вы используете этот фильтр, вы не должны использовать __filter[ids]__. Допускаются значения, разделенные запятыми, но в этом случае использовать их нельзя __filter[fields]__.\n  - __query__ - Задав строку в это свойство клиент будет искать любые соответсвия даннной строке по БД. Вы не должны использовать filter[ids]. Если locale определено, клиент ищит в пределах этого языкового стандарта. В противном случае будет использоваться основной языковой стандарт среды.\n  - __fields__ - Позволяет искать по значению конкретного поля. Используйте snake_case для имен полей. Если locale определено, ищите в пределах этого языкового стандарта. В противном случае будет использоваться основной языковой стандарт среды.\n- __locale__ - Определяет язык для фильтрации \n- __page__ - Свойство для управления пагинацией результатов. Содержит в себе следующие свойства:\n  - __offset__ - Индекс первой записи для выборки. По умолчанию: 0\n  - __limit__ - Количество записей для выборки. Максимум 500 на страницу, по умолчанию 30.\n- __orderBy__ - Свойство для упорядочивания результатов. Требует также если используете filter[type] можно указать только с один элемент. Формат: <имя_поля> _ <НАПРАВЛЕНИЕ (ASC | DESC)>. Вы можете передать несколько правил, разделенных запятыми.\n- __version__ - Тут указывать какую версию данных получить published, по умлчанию или current\n\n# Получение записей по id\n\n> Добавьте, __allPages__ чтобы автоматически разбить запрос на страницы и получить все записи.\n\nПример кода \n\n``` js\nconst { SiteClient } = require(\"datocms-client\");\nconst client = new SiteClient(\"YOUR-API-TOKEN\");\nasync function getFilteredRecords() {\n  const records = await client.items.all(\n    {\n      filter: {\n        ids: \"123,567\",\n      },\n    },\n    {\n      allPages: true,\n    }\n  );\n  console.log(records);\n}\ngetFilteredRecords();\n```\n\nВозвращаемое значение\n\n``` json\n[\n  {\n    id: '123',\n    name: 'Gigio',\n    updatedAt: '2021-07-14T15:46:32.276+02:00',\n    createdAt: '2021-07-14T15:33:03.065+02:00',\n    meta: { ... },\n    itemType: '1234', // `dog` model\n    creator: { id: '777', type: 'account' }\n  },\n  {\n    id: '567',\n    name: 'Felix',\n    updatedAt: '2021-07-14T15:46:32.252+02:00',\n    createdAt: '2021-07-14T15:46:32.249+02:00',\n    meta: { ... },\n    itemType: '5678', // `cat` model\n    creator: { id: '777', type: 'account' }\n  },\n  ...\n]\n```\n\n# Получение отфильтрованного списка записей по полям модели\nВы можете получить разбитый на страницы список записей, отфильтрованных по набору условий для полей. Для каждого поля есть разные варианты, и вы можете комбинировать несколько фильтров вместе.\n\n> filter[type] должно содержать только одно значение.\n\nВ этом примере мы выполняем фильтрацию по однострочному строковому полю и по полю даты.\n\nПример кода \n\n``` js\nconst { SiteClient } = require(\"datocms-client\");\nconst client = new SiteClient(\"YOUR-API-TOKEN\");\nasync function getFilteredRecords() {\n  const records = await client.items.all({\n    filter: {\n      type: \"dog\",\n      fields: {\n        name: {\n          eq: \"Gigio\",\n        },\n        _updated_at: {\n          gt: \"2020-04-18T00:00:00\",\n        },\n      },\n    },\n  });\n  console.log(records);\n}\n\ngetFilteredRecords();\n```\n\nВозвращаемое значение\n\n``` json\n[\n  {\n    id: \"4579273\",\n    name: \"Gigio\",\n    picture: {\n      uploadId: \"1642386\",\n      alt: null,\n      title: null,\n      focalPoint: { x: 0.5, y: 0.5 },\n      customData: {},\n    },\n    description: [],\n    breed: \"Labrador\",\n    age: 4,\n    height: 50.5,\n    dateOfBirth: \"2020-04-17T17:25:00+01:00\",\n    available: true,\n    location: { latitude: 45.0703393, longitude: 7.686864 },\n    color: { red: 239, blue: 156, alpha: 255, green: 208 },\n    json: '{\"additionalData\": \"1234\"}',\n    friends: [\"4572300\", \"4572298\", \"4572297\", \"4572180\", \"4572128\"],\n    updatedAt: \"2020-04-20T11:06:29.130+01:00\",\n    createdAt: \"2020-04-20T11:06:29.126+01:00\",\n    meta: { ... },\n    itemType: \"1234\",\n    creator: { id: \"322\", type: \"access_token\" },\n  },\n];\n\n```\n\n# Получение записей с помощью текстового универсального запроса\nВы можете получить список записей, отфильтрованных по текстовому запросу. Он также будет искать в записях блоков. Вы можете сузить область поиска по некоторым моделям, указав атрибут field [type] использовав либо api_key модели, либо идентификатор модели. Допускается несколько значений, разделенных запятыми. Вы должны указать атрибут locale. По умолчанию будет использоваться основной языковой стандарт среды. Возвращенные записи отсортированы по рангу.\n\nПример кода \n\n``` js\nconst { SiteClient } = require(\"datocms-client\");\nconst client = new SiteClient(\"YOUR-API-TOKEN\");\nasync function getFilteredRecords() {\n  const records = await client.items.all({\n    filter: {\n      type: \"article,blog_post\", // optional, if defined, search in the specified models only\n      query: \"egyptian museum\",\n    },\n    locale: \"en\",\n    order_by: \"_rank_DESC\", // possible values: `_rank_DESC` (default) | `_rank_ASC`\n  });\n  console.log(records);\n}\ngetFilteredRecords();\n\n```\n\nВозвращаемое значение\n\n``` json\n[\n  {\n    id: '59707172',\n    title: { en: 'Egyptian Museum of Torino' },\n    content: { en: 'A must see museum!' },\n    updatedAt: '2021-10-18T11:39:18.282+02:00',\n    createdAt: '2021-10-18T11:30:46.765+02:00',\n    position: 1,\n    parentId: null,\n    meta: { ... },\n    itemType: '210943',\n    creator: { id: '14379', type: 'account' }\n  },\n  {\n    id: '59707173',\n    title: { en: '10 things to do in Torino' },\n    content: { en: '- Visit the egyptian museum\\n- ...' },\n    updatedAt: '2021-10-18T11:39:38.123+02:00',\n    createdAt: '2021-10-18T11:32:07.576+02:00',\n    meta: { ... },\n    itemType: '1195677',\n    creator: { id: '14379', type: 'account' }\n  }\n]\n\n```\n\n# Другой пример и получение всех страниц (nested)\n\nПример кода \n\n``` js\nconst SiteClient = require('datocms-client').SiteClient;\nconst client = new SiteClient('YOUR-API-TOKEN');\nclient.items.all({\n  nested: 'true',\n  filter: {\n    ids: '12,31',\n    type: '44',\n    query: 'foo',\n    fields: {\n      name: {\n        eq: 'Gigio'\n      }\n    }\n  },\n  locale: 'it',\n  page: {\n    offset: 200,\n    limit: 100\n  },\n  order_by: 'name_DESC',\n  version: 'current'\n})\n.then((items) => {\n    items.forEach((item) => {\n      console.log(item);\n    });\n  })\n.catch((error) => {\n  console.error(error);\n});\n// if you want to fetch all the pages with just one call:\nclient.items.all({\n  nested: 'true',\n  filter: {\n    ids: '12,31',\n    type: '44',\n    query: 'foo',\n    fields: {\n      name: {\n        eq: 'Gigio'\n      }\n    }\n  },\n  locale: 'it',\n  order_by: 'name_DESC',\n  version: 'current'\n}, {\n  allPages: true\n})\n.then((items) => {\n    items.forEach((item) => {\n      console.log(item);\n    });\n  })\n\n```\n\nВозвращаемое значение\n\n``` json\n{\n  \"id\": \"4235\",\n  \"title\": \"My first blog post!\",\n  \"content\": \"Lorem ipsum dolor sit amet...\",\n  \"category\": \"24\",\n  \"image\": {\n    \"alt\": \"Alt text\",\n    \"title\": \"Image title\",\n    \"customData\": {},\n    \"focalPoint\": null,\n    \"uploadId\": \"20042921\"\n  },\n  \"meta\": {\n    \"created_at\": \"2020-04-21T07:57:11.124Z\",\n    \"updated_at\": \"2020-04-21T07:57:11.124Z\",\n    \"published_at\": \"2020-04-21T07:57:11.124Z\",\n    \"first_published_at\": \"2020-04-21T07:57:11.124Z\",\n    \"publication_scheduled_at\": \"2020-04-21T07:57:11.124Z\",\n    \"unpublishing_scheduled_at\": \"2020-04-21T07:57:11.124Z\",\n    \"status\": \"draft\",\n    \"is_valid\": true,\n    \"current_version\": \"4234\",\n    \"stage\": \"\"\n  },\n  \"itemType\": \"44\",\n  \"creator\": \"312\"\n}\n```\n",
        "message": "",
        "created": "2021-11-22T13:00:58.537Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "7493576d-db56-431d-97ed-d5ba41657362",
      "emoji": null,
      "title": "Инициализация",
      "content": "",
      "headId": 1558348,
      "archivedAt": null,
      "folderPathname": "/DatoCMS",
      "parentFolderId": "eb22223a-df04-44f4-9bb0-726eae2c014b",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-22T11:44:33.399Z",
      "updatedAt": "2021-11-22T11:51:18.492Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1558348,
        "docId": "7493576d-db56-431d-97ed-d5ba41657362",
        "content": "1. Установка\n\n``` \nnpm install --save-dev datocms-client\n```\n\n2. Инициализация клиента \n\n``` js\nconst client = new SiteClient(\n  'YOUR_API_READWRITE_TOKEN', \n  { environment: 'my-sandbox' },\n);\n```",
        "message": "",
        "created": "2021-11-22T11:51:18.482Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "6efe6788-e5a7-4e24-bce8-67089f0ca15b",
      "emoji": null,
      "title": "Докеризация",
      "content": "",
      "headId": 1552374,
      "archivedAt": null,
      "folderPathname": "/Nest-Prisma-template",
      "parentFolderId": "966441c0-7a90-453f-b559-c3b723c275c6",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-20T15:48:48.159Z",
      "updatedAt": "2021-11-20T16:04:55.561Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1552374,
        "docId": "6efe6788-e5a7-4e24-bce8-67089f0ca15b",
        "content": "Docker 🐳 позволяет создавать согласованные контейнеры приложений для сред разработки, тестирования и производства. В этом посте вы докеризуете приложение NestJS 😸 с Prisma, подключающимся к базе данных PostgreSQL 🐘.\n\n\nСоздайте Dockerfileв корне вашего приложения Nest\n```\ntouch Dockerfile\n```\n\n``` Dockerfile\nFROM node:14 AS builder\n\n# Create app directory\nWORKDIR /app\n\n# A wildcard is used to ensure both package.json AND package-lock.json are copied\nCOPY package*.json ./\nCOPY prisma ./prisma/\n\n# Install app dependencies\nRUN npm install\n\nCOPY . .\n\nRUN npm run build\n\nFROM node:14\n\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/package*.json ./\nCOPY --from=builder /app/dist ./dist\n\nEXPOSE 3000\nCMD [ \"npm\", \"run\", \"start:prod\" ]\n\n```\n\nНо подождите ... что происходит в __Dockerfile__ 🤔❓ См. Разбивку по каждому шагу ниже.\n\nНе забудьте создать __.dockerignore__ файл рядом с вашим Dockerfile:\n``` .dockerignore\nnode_modules\nnpm-debug.log\n```\n\nКоманда __COPY__ игнорирует эти локальные файлы и папки и не копирует их в образ Docker, чтобы предотвратить перезапись установленных модулей в образе.\n\n``` Dockerfile\nFROM node:14 AS builder\n```\n\nПервая строка указывает Docker использовать последнюю версию LTS14 в node качестве базового образа для сборки контейнера. Чтобы оптимизировать размер образа контейнера, вы используете многоступенчатую сборку и назначаете имя вашему базовому образу AS builder.\n\n ## Рабочий каталог\n ``` Dockerfile\n# Create app directory\nWORKDIR /app\n```\n\nСоздайте рабочий каталог для вашего приложения, в котором хранится ваш код. Все команды ( RUN, COPY) выполняются внутри этого каталога.\n\n ## Установка\n  ``` Dockerfile\n# A wildcard is used to ensure both package.json AND package-lock.json are copied\nCOPY package*.json ./\nCOPY prisma ./prisma/\n\n# Install app dependencies\nRUN npm install\n\n```\n\nЗатем вам нужно установить зависимости вашего приложения внутри образа Docker. __package.json__ и __package-lock.json__ копируются. Для создания __Prisma Client__ требуется __schema.prisma__ файл. ```COPY prisma ./prisma/``` копирует весь __prisma__ каталог на случай, если вам также понадобятся миграции.\n\nУстановите все зависимости ```RUN npm install```(также для разработчиков). Это позволяет вам создавать приложение Nest внутри образа Docker. Prisma Client создается сразу после того, как он определяет свой собственный обработчик.\n\n## Создать приложение\n\n``` Dockerfile\nCOPY . .\n\nRUN npm run build\n\n```\n\nЧтобы создать приложение __Nest__, скопируйте все исходные файлы (исключения в .dockerignore) в образ Docker. Пришло время создать ваше приложение ```RUN npm run build```.\n\n##  Запустите приложение\n\n```Dockerfile\nFROM node:14\n\n```\n\nВторой __FROM__ - это второй этап многоэтапной сборки, который используется для запуска вашего приложения.\n\n```Dockerfile\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/package*.json ./\nCOPY --from=builder /app/dist ./dist\n\n```\n\nКопирование из ваших __builder__ изображений только файлы и папки , необходимые для запуска приложения Nest.\n\n```Dockerfile\nEXPOSE 3000\nCMD [ \"npm\", \"run\", \"start:prod\" ]\n\n```\n\nПриложения Nest обычно привязываются к порту __3000__ , __EXPOSE__ к тому же порту для вашего образа Docker. Последний шаг - это команда для запуска приложения Nest с использованием CMD.\n\n# Создайте и запустите свой образ\n\n``` bash\n# give your docker image a name\ndocker build -t <your username>/nest-api .\n\n# for example\ndocker build -t nest-api .\n\n```\n\nПосле успешной сборки образа Docker запустите его с помощью этой команды\n\n``` bash\ndocker run -p 3000:3000 --env-file .env -d <your username>/nest-api \n\n```\n\n__Prisma Client__ требует __DATABASE_URL__ переменную среды, которую вы передаете с помощью ```--env-file .env``` флага. Используйте этот __.env__ файл для дополнительных переменных среды (порт, секрет JWT и т. Д.) В корневой папке.\n\nОткройте __localhost:3000__, чтобы убедиться, что ваше приложение Nest работает с Docker.\n\n# Добавить docker-compose с PostgreSQL\n\nDocker Compose позволяет вам определять и запускать несколько контейнеров Docker вместе. Здесь вы настраиваете файл компоновки Docker для приложения Nest и базы данных PostgreSQL.\n\nСоздайте файл набора Docker\n\n``` bash\ntouch docker-compose.yml\n\n```\n\n``` yml\nversion: '3.8'\nservices:\n  nest-api:\n    container_name: nest-api\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - 3000:3000\n    depends_on:\n      - postgres\n    env_file:\n      - .env\n\n  postgres:\n    image: postgres:13\n    container_name: postgres\n    restart: always\n    ports:\n      - 5432:5432\n    env_file:\n      - .env\n    volumes:\n      - postgres:/var/lib/postgresql/data\n\nvolumes:\n  postgres:\n    name: nest-db\n\n```\n\nПервый контейнер __nest-api__ создает образ Docker на основе __Dockerfile__ вашего приложения Nest с помощью Prisma. Второй контейнер - создание базы данных __postgres__ с использованием __postgres__ образа Docker в версии 13. Для множества образов Postgres POSTGRES_USER, POSTGRES_PASSWORD и POSTGRES_DB переменные окружения в корневом .env файле.\n\n``` bash\nPOSTGRES_USER=prisma\nPOSTGRES_PASSWORD=topsecret\nPOSTGRES_DB=food\n\n```\n\nДля подключения к базе данных PostgreSQL Docker образу настройки DATABASE_URL в вашем .env файле. Введите свои значения в формат URL-адреса подключения Postgres.\n\n``` bash\npostgresql://USER:PASSWORD@HOST:PORT/DB?schema=NAME&sslmode=prefer\n\n```\n\nВ этом примере добавьте в .env файл следующую переменную. Это HOST при подключении из другого образа Docker либо имя службы, либо имя контейнера - и то, и другое postgres.\n\n``` bash\nDATABASE_URL=postgresql://prisma:topsecret@postgres:5432/food?schema=food&sslmode=prefer\n\n```\n\nПора 🕙 запустить приложение Nest и образ Postgres Docker. Убедитесь, что порты 3000 и 5432 еще не используются.\n``` bash\ndocker-compose up\n# or detached\ndocker-compose up -d\n```\n\n# Prisma Migrate Docker-контейнер Postgres\nЗамените хост __postgres__ на, __localhost__ если вы хотите выполнять миграции Prisma локально вашего контейнера Postgres Docker. Обновление DATABASE_URL в prisma.env к\n\n``` bash\nDATABASE_URL=postgresql://prisma:topsecret@localhost:5432/food?schema=food&sslmode=prefer\n\n```\n\nТеперь вы можете запустить ```npx prisma migrate save --experimental``` и ```npx prisma migrate save --experimental``` или даже заполнить базу данных, если хотите.\n\nОтлично, теперь расслабьтесь и расслабьтесь 🏝, и пусть Docker сделает всю работу за вас.",
        "message": "",
        "created": "2021-11-20T16:04:55.528Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "4ee01bee-3655-4c54-a01a-f1b27da8211f",
      "emoji": null,
      "title": "DBML генератор схем",
      "content": "",
      "headId": 1552347,
      "archivedAt": null,
      "folderPathname": "/Nest-Prisma-template/Prisama",
      "parentFolderId": "0eec9f0c-a7af-47b7-a9de-d842cf20cb5b",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-20T15:42:27.505Z",
      "updatedAt": "2021-11-20T15:45:52.109Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1552347,
        "docId": "4ee01bee-3655-4c54-a01a-f1b27da8211f",
        "content": "Просто установите генератор DBML\n\n``` \nnpm install -D prisma-dbml-generator\n```\n\nДобавьте генератор в свой __schema.prisma__\n\n```\ngenerator dbml {\n  provider = \"prisma-dbml-generator\"\n}\n```\n\nЗапуск __npx prisma generate__ по следующей схеме Prisma\n\n```\nmodel User {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  email     String   @unique\n  name      String?\n  posts     Post[]\n  profile   Profile?\n  /// user role\n  role      Role     @default(USER)\n}\n\n/// User profile\nmodel Profile {\n  id     Int     @default(autoincrement()) @id\n  bio    String?\n  user   User    @relation(fields: [userId], references: [id])\n  userId Int     @unique\n}\n\nmodel Post {\n  id         Int        @id @default(autoincrement())\n  title      String     @default(\"\")\n  content    String?\n  published  Boolean    @default(false)\n  author     User?      @relation(fields: [authorId], references: [id])\n  authorId   Int?\n  categories Category[]\n}\n\nmodel Category {\n  id    Int    @id @default(autoincrement())\n  name  String\n  posts Post[]\n}\n\n/// user role\nenum Role {\n  ADMIN /// allowed to do everything\n  USER\n}\n\n```\n\nгенерирует следующее __schema.dbml__ для __prisma/dbml__\n\n```\nTable User {\n  id Int [pk, increment]\n  createdAt DateTime [default: `now()`, not null]\n  updatedAt DateTime [not null]\n  email String [unique, not null]\n  name String\n  posts Post\n  profile Profile\n  role Role [not null, default: 'USER', note: 'user role']\n}\n\nTable Profile {\n  id Int [pk, increment]\n  bio String\n  user User [not null]\n  userId Int [unique, not null]\n\n  Note: 'User profile'\n}\n\nTable Post {\n  id Int [pk, increment]\n  title String [not null, default: '']\n  content String\n  published Boolean [not null, default: false]\n  author User\n  authorId Int\n  categories Category\n}\n\nTable Category {\n  id Int [pk, increment]\n  name String [not null]\n  posts Post\n}\n\nTable CategoryToPost {\n  categoryId Int [ref: > Category.id]\n  postId Int [ref: > Post.id]\n}\n\nEnum Role {\n  ADMIN\n  USER\n}\n\nRef: Profile.userId - User.id\n\nRef: Post.authorId > User.id\n\n```\n\nСкопируйте __schema.dbml__ контент и визуализируйте в сервисе [https://dbdiagram.io/d](url) его как диаграмму отношений сущностей:\n\nВы должны видеть этот вывод каждый раз, когда запускаете ```npx prisma generate```\n\n```\n$ npx prisma generate\nEnvironment variables loaded from prisma/.env\n\n✔ Generated Prisma Client to ./node_modules/@prisma/client in 281ms\n\n✔ Generated DBML Schema to ./prisma/dbml in 5ms\n\nYou can now start using Prisma Client in your code:\n\n``\nimport { PrismaClient } from '@prisma/client'\n// or const { PrismaClient } = require('@prisma/client')\n\nconst prisma = new PrismaClient()\n``\n\nExplore the full API: http://pris.ly/d/client\n\n```",
        "message": "",
        "created": "2021-11-20T15:45:52.101Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "01f816c7-bd76-4304-8dfb-1d1ca5d69441",
      "emoji": null,
      "title": "Запрос БД с Prisma",
      "content": "",
      "headId": 1552271,
      "archivedAt": null,
      "folderPathname": "/Nest-Prisma-template/Prisama",
      "parentFolderId": "0eec9f0c-a7af-47b7-a9de-d842cf20cb5b",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-20T15:10:16.886Z",
      "updatedAt": "2021-11-20T15:28:27.954Z",
      "version": 7,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1552271,
        "docId": "01f816c7-bd76-4304-8dfb-1d1ca5d69441",
        "content": "# Установка зависимостей \nУстановка __nextjs-prisma__ которые поможет удобно интегрировать Prisma в проект.\n``` \nnest add nestjs-prisma\n```\n\n# Интеграция в проект\n\nДобавьте __PrismaModule__ в раздел импорта в вашем __AppModule__ или любых других модулях, чтобы получить доступ к __PrismaService__ через который мы можем получить доступ к БД в сервисах, контролерах и резольверах.\n\n```ts\nimport { Module } from '@nestjs/common';\nimport { PrismaModule } from 'nestjs-prisma';\n\n@Module({\n  imports: [PrismaModule.forRoot()],\n})\nexport class AppModule {}\n\n```\n\n__PrismaModule__ позволяет использовать глобально и передавать параметры в  __PrismaClient__. Короче говоря параметры для работы призмы в нашем проекте\n\n``` ts\nimport { Module } from '@nestjs/common';\nimport { PrismaModule } from 'nestjs-prisma';\n\n@Module({\n  imports: [\n    PrismaModule.forRoot({\n      isGlobal: true,\n      prismaServiceOptions: {\n        prismaOptions: { log: ['info'] },\n        explicitConnect: true,\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n\n```\n\nКроме того, __PrismaModule__ предоставляет __forRootAsync__ возможность асинхронной передачи параметров. Один из вариантов - использовать заводскую функцию:\n\n``` ts\nimport { Module } from '@nestjs/common';\nimport { PrismaModule } from 'nestjs-prisma';\n\n@Module({\n  imports: [\n    PrismaModule.forRootAsync({\n      isGlobal: true,\n      useFactory: () => ({\n        prismaOptions: {\n          log: ['info', 'query'],\n        },\n        explicitConnect: false,\n      }),\n    }),\n  ],\n})\nexport class AppModule {}\n\n```\n\nВы можете вводить зависимости, например __ConfigModule__ загружая параметры из файлов .env.\n\n``` ts \nimport { Module } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { PrismaModule } from 'nestjs-prisma';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      isGlobal: true,\n    }),\n    PrismaModule.forRootAsync({\n      isGlobal: true,\n      useFactory: async (configService: ConfigService) => {\n        return {\n          prismaOptions: {\n            log: [configService.get('log')],\n            datasources: {\n              db: {\n                url: configService.get('DATABASE_URL'),\n              },\n            },\n          },\n          explicitConnect: configService.get('explicit'),\n        };\n      },\n      inject: [ConfigService],\n    }),\n  ],\n})\nexport class AppModule {}\n\n```\n\nВ качестве альтернативы вы можете использовать класс вместо фабрики:\n\n``` ts\nimport { Module } from '@nestjs/common';\nimport { PrismaModule } from 'nestjs-prisma';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      isGlobal: true,\n    }),\n    PrismaModule.forRootAsync({\n      isGlobal: true,\n      useClass: PrismaConfigService,\n    }),\n  ],\n})\nexport class AppModule {}\n\n```\n\nСоздайте __PrismaConfigService__ и расширите его с помощью __PrismaOptionsFactory__\n\n``` ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaOptionsFactory, PrismaServiceOptions } from '.nestjs-prisma';\n\n@Injectable()\nexport class PrismaConfigService implements PrismaOptionsFactory {\n  constructor() {\n    // TODO inject any other service here like the `ConfigService`\n  }\n\n  createPrismaOptions(): PrismaServiceOptions | Promise<PrismaServiceOptions> {\n    return {\n      prismaOptions: {\n        log: ['info', 'query'],\n      },\n      explicitConnect: true,\n    };\n  }\n}\n\n```\n\n# PrismaClientExceptionFilter\n__nestjs-prisma__ предоставляет объект __PrismaClientExceptionFilter__ для перехвата необработанной ошибки __PrismaClientKnownRequestError__ и возврата других кодов состояния вместо 500 Internal server error.\n\nЧтобы использовать фильтр, у вас есть два следующих варианта.\n\n1. Создайте экземпляр фильтра в своем __main.ts__ и передайте __HttpAdapterHost__\n\n```ts\nimport { ValidationPipe } from '@nestjs/common';\nimport { HttpAdapterHost, NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { PrismaClientExceptionFilter } from 'nestjs-prisma';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  const { httpAdapter } = app.get(HttpAdapterHost);\n  app.useGlobalFilters(new PrismaClientExceptionFilter(httpAdapter));\n\n  await app.listen(3000);\n}\nbootstrap();\n\n```\n\n2. Использовать __APP_FILTER__ токен в любом модуле\n\n``` ts\nimport { Module } from '@nestjs/common';\nimport { APP_FILTER } from '@nestjs/core';\nimport { PrismaClientExceptionFilter } from 'nestjs-prisma';\n\n@Module({\n  providers: [\n    {\n      provide: APP_FILTER,\n      useClass: PrismaClientExceptionFilter,\n    },\n  ],\n})\nexport class AppModule {}\n\n```",
        "message": "",
        "created": "2021-11-20T15:28:27.945Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f42a6693-10a3-4d1a-b3e1-a706f27d2dea",
      "emoji": null,
      "title": "Работа с данными",
      "content": "",
      "headId": 1526180,
      "archivedAt": null,
      "folderPathname": "/BoxHill",
      "parentFolderId": "c4ccaa1e-4560-46b2-a4a0-56dd9722d26c",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-16T10:10:16.832Z",
      "updatedAt": "2021-11-16T10:17:41.411Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1526180,
        "docId": "f42a6693-10a3-4d1a-b3e1-a706f27d2dea",
        "content": "Для правильной выгрузки данных необходимо обращать внимание не только на json файлы но и на функции которые их получают это поможет получить данные полностью избежав ошибок. После необходимо так же обращать внимание на то, нужны ли нам все данные для каждого шаблона.",
        "message": "",
        "created": "2021-11-16T10:17:41.403Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f5bab1b2-bdc7-4afe-a885-6ee375c3a71a",
      "emoji": null,
      "title": "3 часть плагины",
      "content": "",
      "headId": 1522418,
      "archivedAt": null,
      "folderPathname": "/Nest-Prisma-template/Graphql code first",
      "parentFolderId": "1ea0959e-8104-4589-80ee-89c481887df7",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-15T20:43:55.759Z",
      "updatedAt": "2021-11-15T20:49:30.987Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1522418,
        "docId": "f5bab1b2-bdc7-4afe-a885-6ee375c3a71a",
        "content": "Nest 7 предоставляет новый подключаемый модуль GraphQL, который сокращает количество шаблонов декораторов для наших моделей, входных данных , аргументов и файлов сущностей . Включите плагин, добавив __compilerOptions__ в __nest-cli.json__:\n\n```js\n{\n  \"collection\": \"@nestjs/schematics\",\n  \"sourceRoot\": \"src\",\n  \"compilerOptions\": {\n    \"plugins\": [\"@nestjs/graphql/plugin\"]\n  }\n}\n```\n\nПлагин автоматически обрабатывает декораторы для файлов с суффиксом ```['.input.ts', '.args.ts', '.entity.ts', '.model.ts']```. Если вы хотите использовать собственные суффиксы, добавьте их в параметр плагинов:\n\n``` js\n\"plugins\": [\n  {\n    \"name\": \"@nestjs/graphql/plugin\",\n    \"options\": {\n      \"typeFileNameSuffix\": [\".input.ts\", \".model.ts\"]\n    }\n  }\n]\n\n```\n\nДавайте очистим шаблон наших моделей. Перед плагином модели они выглядят так:\n\n```js\nimport { ObjectType, Field, Int, HideField } from '@nestjs/graphql';\nimport { Hobby } from './hobby.model';\n\n@ObjectType()\nexport class User {\n  @Field(type => Int)\n  id: number;\n\n  @Field({ name: 'registeredAt' })\n  createdAt: Date;\n\n  updatedAt: Date;\n\n  email: string;\n\n  @HideField()\n  password: string;\n\n  name?: string;\n\n  hobbies: Hobby[];\n}\n\n```\n\n``` ts\n@ObjectType()\nexport class Hobby {\n  @Field(type => Int)\n  id: number;\n\n  name: string;\n}\n\n```\n\nПосле удаления лишних шаблонных декораторов модели выглядят так:\n\n``` ts\nimport { ObjectType, Field, Int, HideField } from '@nestjs/graphql';\nimport { Hobby } from './hobby.model';\n\n@ObjectType()\nexport class User {\n  @Field(type => Int)\n  id: number;\n\n  @Field({ name: 'registeredAt' })\n  createdAt: Date;\n\n  updatedAt: Date;\n\n  email: string;\n\n  @HideField()\n  password: string;\n\n  name?: string;\n\n  hobbies: Hobby[];\n}\n\n```\n\n``` ts\n@ObjectType()\nexport class Hobby {\n  @Field(type => Int)\n  id: number;\n\n  name: string;\n}\n\n```\n\nМы можем добавить __@Field__ к любому свойству, чтобы переопределить документацию, а также предполагаемый тип. Например, __number__ здесь подразумевается тип GraphQL, __Float__ мы можем использовать, ```@Field(type => Int)``` чтобы изменить его на __Int__ тип.",
        "message": "",
        "created": "2021-11-15T20:49:30.978Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "fe2a3efe-bfdb-4922-b009-d34c821d8df7",
      "emoji": null,
      "title": "2 часть резолверы graphql",
      "content": "",
      "headId": 1522361,
      "archivedAt": null,
      "folderPathname": "/Nest-Prisma-template/Graphql code first",
      "parentFolderId": "1ea0959e-8104-4589-80ee-89c481887df7",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-15T20:11:15.043Z",
      "updatedAt": "2021-11-15T20:31:30.672Z",
      "version": 8,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1522361,
        "docId": "fe2a3efe-bfdb-4922-b009-d34c821d8df7",
        "content": "Впервой части мы создали модели теперь пора приняться за создание резолверов\n\nЧто бы сгенерировать резольвер через cli nestjs необходимо выполнить одну из следующих команд:\n\n```\nnest generate resolver <name>\n\n// Либо ее короткую версию \n\nnest g r <name>\n```\n\nВ примере мы прошпишим команды для создания резолверов под модели  из первой части\n\n```\nnest g r user\nnest g r hobby\n```\n\nНаши преобразователи добавляются в массив providers в app.module.ts. Но они так же могут добваляться и в личный модуль если тот был создан ранее.\n\nДавайте взглянем на user.resolver.ts\n\n```ts\nimport { Resolver } from '@nestjs/graphql';\nimport { User } from '../models/user.model';\n\n@Resolver(of => User)\nexport class UserResolver {\n  ...\n}\n```\n\nОбъявляя функцию __of__ в __@Resolver__ декораторе (например ```@Resolver(of => User)```), она используется для предоставления родительского объекта в __@ResolveField__. Мы поговорим __@ResolveField__ немного позже.\n\nДобавьте __@Query__ в свои преобразователи, чтобы создавать новые запросы GraphQL в вашей схеме. Создадим функцию запроса, возвращающую все __users()__. Используйте скобки внутри декоратора, __@Query(returns => [User])__ чтобы объявить возвращаемое значение массива.\n\n``` ts\nimport { Resolver, Query } from '@nestjs/graphql';\nimport { User } from '../models/user.model';\nimport { PrismaService } from '../prisma/prisma.service';\n\n@Resolver(of => User)\nexport class UserResolver {\n  constructor(private prisma: PrismaService) {}\n\n  @Query(returns => [User])\n  async users() {\n    return this.prisma.user.findMany();\n  }\n}\n```\n\nПриведенный выше код генерирует следующий запрос к нашей схеме:\n\n``` gql\ntype Query {\n  users: [User!]!\n}\n\n```\n\nА __User__ имеет отношение ко многим к __Hobby__. Чтобы получить __Hobbies__ свойство от пользователя, мы используем __@ResolveField__ декоратор. \n\nСоздав резолвер с таким декоратором и указав в параметрах родительскую модель внутри этого метода мы можем вытащить с помощью модели и orm данные из другой таблицы имеющие отношение к этой модели.\n\n``` ts\nimport { Resolver, Query, ResolveField, Parent } from '@nestjs/graphql';\nimport { User } from '../models/user.model';\nimport { PrismaService } from '../prisma/prisma.service';\n\n@Resolver(of => User)\nexport class UserResolver {\n  constructor(private prisma: PrismaService) {}\n\n  @Query(returns => [User])\n  async users() {\n    return this.prisma.user.findMany();\n  }\n\n  @ResolveField()\n  async hobbies(@Parent() user: User) {\n    return this.prisma.hobby.findMany({\n      where: { user: { id: user.id } }\n    });\n  }\n}\n```\n",
        "message": "",
        "created": "2021-11-15T20:31:30.663Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "6ef57847-b5e7-4394-a823-46d9157876e0",
      "emoji": null,
      "title": "1 часть типы graphql",
      "content": "",
      "headId": 1522262,
      "archivedAt": null,
      "folderPathname": "/Nest-Prisma-template/Graphql code first",
      "parentFolderId": "1ea0959e-8104-4589-80ee-89c481887df7",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-15T19:49:25.842Z",
      "updatedAt": "2021-11-15T20:07:51.561Z",
      "version": 7,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1522262,
        "docId": "6ef57847-b5e7-4394-a823-46d9157876e0",
        "content": "Схема GraphQL содержит множество типов и запросов . Схема увеличивается в размере и сложности с каждым новым запросом, изменением и типом. GraphQL Code First позволяет нам автоматически генерировать схему GraphQL с использованием TypeScript и декораторов. Это помогает нам сосредоточиться на написании .tsфайлов, и нам не нужно писать схему GraphQL самостоятельно.\n\n```@nestjs/graphql``` предоставляет все декораторы для создания нашей схемы. Вот несколько декораторов и их использование:\n\n- __@ObjectType()__ сгенерировать класс как Type\n- __@Field()__ сгенерировать свойство класса как поле\n- __@InputType()__ сгенерировать класс как вход\n- __@Args__ генерировать параметры метода как аргументы\n- __@Query()__ генерировать метод как запрос\n- __@Mutation()__ генерировать метод как мутацию\n- __@ResolveField__ разрешить свойство отношения\n\n# Тип Graphql\n\nНачните с создания моделей как TypeScript ```class```.\n\n### hobby.ts\n``` ts\nexport class Hobby {\n  id: number;\n  name: string;\n}\n```\n\n### users.ts\n``` ts\nexport class User {\n  id: number;\n  createdAt: Date;\n  updatedAt: Date;\n  email: string;\n  password: string;\n  name?: string;\n  hobbies: Hobby[];\n}\n```\n\nЧто бы нам представить наши вышесозданные модели в схеме GraphQL. Необходимо добавить  __@ObjectType()__ в класс TypeScript.\n\n### hobby.ts\n``` ts\n@ObjectType()\nexport class Hobby {\n  ...\n}\n```\n\n### users.ts\n``` ts\nimport { ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\nexport class User {\n  ...\n}\n\n```\n\nЗатем мы используем __@Field__ декоратор для каждого свойства класса, предоставляя дополнительную информацию о типе и состоянии (обязательном или необязательном).\n\n### hobby.ts\n``` ts\n@ObjectType()\nexport class Hobby {\n  @Field(type => Int)\n  id: number;\n\n  @Field(type => String)\n  name: string;\n}\n\n```\n\n### users.ts\n``` ts\nimport { ObjectType, Field, Int } from '@nestjs/graphql';\n\n@ObjectType()\nexport class User {\n  @Field(type => Int)\n  id: number;\n\n  @Field(type => Date, { name: 'registeredAt' })\n  createdAt: Date;\n\n  @Field(type => Date)\n  updatedAt: Date;\n\n  @Field(type => String)\n  email: string;\n\n  password: string;\n\n  @Field(type => String, { nullable: true })\n  name?: string;\n\n  @Field(type => [Hobby])\n  hobbies: Hobby[];\n}\n```\n\nИ в результате если мы используем класс(модель) __User__ в resolver то нест сгенирирует нам следующую схему\n\n``` gql\ntype User {\n  id: Int!\n  registeredAt: DateTime!\n  updatedAt: DateTime!\n  email: String!\n  name: String\n  hobbies: [Hobby!]!\n}\n\n```\n\n- __@Field__ - принимает необязательную функцию типа (например type => String)\n- Объявите поле как массив, используя обозначение скобок __[ ]__ в функции типа (например, ``type => [Hobby]``)\n- Необязательный __FieldOptions__ объект для изменения сгенерированной схемы\n- __name__: имя свойства  в схеме (пример задачи нового имени описан в свойстве createdAt)\n- __description__: добавление описания поля\n- __deprecationReason__: добавление уведомления об устаревании\n- __nullable__: объявить поле обязательным или необязательным, как поле __name__ в пример.\n- Если мы не хотим что бы свойство описывалось в схеме, то просто не помечаем его декоратором @Field\n\nПодробнее об этом деле в документации Nextjs [https://docs.nestjs.com/graphql/resolvers#object-types](url)",
        "message": "",
        "created": "2021-11-15T20:07:41.842Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "74b18de7-c27b-40ca-9cf7-327f30755eb6",
      "emoji": null,
      "title": "Общее описание",
      "content": "",
      "headId": 1552456,
      "archivedAt": null,
      "folderPathname": "/Nest-Prisma-template/Структура src",
      "parentFolderId": "98866719-4253-426b-8e2e-4bd2ea5d2657",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-15T19:14:41.809Z",
      "updatedAt": "2021-11-20T17:00:13.951Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1552456,
        "docId": "74b18de7-c27b-40ca-9cf7-327f30755eb6",
        "content": "src это основная папка для работы с сервером. Здесь зада различных самых различных параметров работы сервера, направленных в первую очередь на прием данных их обработку, валидацию и отдачу.\n\n# Короткое описание корневых элементов \n1. __schema.graphql__ - Содержит типизированные схемы для работы graphql (типы данный с которыми он работает)\n2. __main.ts__ - Точка входа сервера, место где он инциализиреться (через задачу различных параметров) и запускается. \n3. __app.module.ts__ - Файл главного модуля сервера, учитывая что архитектура nestjs построена на модулях, трудно переоценить этот файл так как он содержит в себе подключения и настройку всех остальных модулей сервера. \n4. __services__ - Содержит в себе сервисы суть которых заключается в непосредственном взаоимодействии с БД(через модели), и остальной бизнес логики (кароче что не работает с запросами на прямую но при этом должно что то делать идет в сервисы)\n5. __resolvers__ - Обработчики графовских запросов. Их задача принимать запросы и делигировать задач сервисам и возвращать результаты их работы.\n6. __models__ -  Тут объявляються модели который преобразуются в схемы graphql а так же нужны для работы с ними в резолверах\n7. __guards__ - Зесь строяться классы которые затем вешаються нарельверы либо контроллеры и позволяют валидировать их, к примеру не пропускать запросы без токена\n8. __decorators__ - Декораторы это такие кастомизаторы классов (а в nest почти все на них построенно) на их основе можно всячески модифицировать классы\n9. __controllers__ - Приемщики запросов и генераторы ответов с помощью моделей и сервисов\n10. __configs__ - Тут сидят различные конфигурации проекта что то вроде прокаченного файла .env\n11. __common__ - Место для различных кастомных модулей по типу пагинацииб новых типов данных и т.д.",
        "message": "",
        "created": "2021-11-20T17:00:13.940Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f96dae94-ff3e-40f5-bdb9-efab24b4acb6",
      "emoji": null,
      "title": "Пример вариантивного примения свойств",
      "content": "",
      "headId": 1514791,
      "archivedAt": null,
      "folderPathname": "/React/Styled-components",
      "parentFolderId": "350a81c3-e095-4d76-b9c3-2008e483ce37",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-14T12:10:52.089Z",
      "updatedAt": "2021-11-14T12:12:11.479Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1514791,
        "docId": "f96dae94-ff3e-40f5-bdb9-efab24b4acb6",
        "content": "Решил вынести этот пример работы со стилями в компонентах так как он включает в себя весьма удобные практики.\n\n``` js\nimport React from 'react';\nimport styled, {css, keyframes} from 'styled-components'\n\nconst rotateAnimation = keyframes`\n    0% {\n        transform: rotateZ(0deg);\n    }\n    \n    100% {\n        transform: rotateZ(360deg);\n    }\n`\n\nconst StyledButton = styled.button.attrs(props => ({\n    outlined: true\n}))`\n    border: none;\n    padding: 10px 15px;\n    font-size: 18px;\n    cursor: pointer;\n    \n    &:focus {\n        outline: none; \n    }\n    \n    &:hover {\n        animation: ${rotateAnimation} 1s infinite linear;\n    }\n    \n    align-self: ${({align}) => align || 'stretch'};\n    \n    ${props => props.primary && css`\n        color: ${({color}) => color || 'white'};\n        background-color: ${({background}) => background || 'white'};\n    `}\n    \n    ${props => props.outlined && css`\n        color: ${props => props.color || props.theme.colors.primary};\n        border: 1px solid color: ${props => props.color || props.theme.colors.primary};;\n        background: transparent;\n    `}\n`\n\nconst LargeButton = styled(StyledButton)`\n    font-size: 32px;\n`\n\nconst Button = (props) => {\n    return <LargeButton {...props}/>;\n};\n\nexport default Button\n```",
        "message": "",
        "created": "2021-11-14T12:12:11.471Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "3a42ea85-75d9-4ad7-ad70-3f910969359c",
      "emoji": null,
      "title": "Тема",
      "content": "",
      "headId": 1514788,
      "archivedAt": null,
      "folderPathname": "/React/Styled-components",
      "parentFolderId": "350a81c3-e095-4d76-b9c3-2008e483ce37",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-14T11:56:48.395Z",
      "updatedAt": "2021-11-14T12:10:41.555Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1514788,
        "docId": "3a42ea85-75d9-4ad7-ad70-3f910969359c",
        "content": "Тема позволяет задать определенные значения для свойств в одном месте и в последствии получать к ним доступ при задачи свойств конкретным компонентам из всего проекта. При этом меняя их в параметрах темы они будут меняться по всему приложению.  \n\nТут мы задаем свойства темы в файле index.js. После оборачиваем в __ThemeProvider__ Все приложение и передаем туда объект темы. Кстати как видим здесь можно так же задавать медиа-запросы что поможет при создании контейнеров\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport {ThemeProvider} from \"styled-components\";\n\nconst theme = {\n    colors: {\n        primary: \"red\",\n        secondary: \"red\",\n    },\n    media: {\n        phone: \"(max-width: 425px)\",\n        tablet: \"(max-width: 768px) and (min-width: 425px)\",\n    }\n}\n\nReactDOM.render(\n  <React.StrictMode>\n      <ThemeProvider theme={theme}>\n          <App />\n      </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\nИ после при создании стилизированного компонента мы можем получить доступ к свойствам темы следующим образом\n\n``` js\nimport React from 'react';\nimport styled from \"styled-components\";\n\nconst StyledLine = styled.div`\n    font-size: 24px;\n    color: ${props => props.theme.colors.primary};\n`\n\nconst Line = (props) => {\n    return <StyledLine {...props} />;\n};\n\nexport default Line;\n```",
        "message": "",
        "created": "2021-11-14T12:10:41.547Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "5a3ac497-cc43-4a02-906e-3bda4f4293a0",
      "emoji": null,
      "title": "Глобальные стили",
      "content": "",
      "headId": 1514745,
      "archivedAt": null,
      "folderPathname": "/React/Styled-components",
      "parentFolderId": "350a81c3-e095-4d76-b9c3-2008e483ce37",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-14T11:53:54.968Z",
      "updatedAt": "2021-11-14T11:56:47.216Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1514745,
        "docId": "5a3ac497-cc43-4a02-906e-3bda4f4293a0",
        "content": "Глобальные стили распространяються на весь сайт, в них очень удобно заносиить к примеру обнуляющие стили\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport {createGlobalStyle, ThemeProvider} from \"styled-components\";\n\n// Создание стилей происходит следующим образом\nconst Global = createGlobalStyle`\n    *{\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n        font-family: consolas;\n    }\n`\n\nReactDOM.render(\n  <React.StrictMode>\n  //Далее что бы они применились их достаточно добавить в рендер\n          <Global/>\n          <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n```",
        "message": "",
        "created": "2021-11-14T11:56:47.208Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "b8a40312-2d4f-48ec-ab30-a155da4b7296",
      "emoji": null,
      "title": "Анимации",
      "content": "",
      "headId": 1514729,
      "archivedAt": null,
      "folderPathname": "/React/Styled-components",
      "parentFolderId": "350a81c3-e095-4d76-b9c3-2008e483ce37",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-14T11:49:40.347Z",
      "updatedAt": "2021-11-14T11:53:58.493Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1514729,
        "docId": "b8a40312-2d4f-48ec-ab30-a155da4b7296",
        "content": "```js\nimport React from 'react';\nimport styled, {css, keyframes} from 'styled-components'\n// Создаем саму анимацию, в процентном соотношении от 0 до 100 \n// указывая что и когда объект анимации должен будет сделать  \nconst rotateAnimation = keyframes`\n    0% {\n        transform: rotateZ(0deg);\n    }\n    \n    100% {\n        transform: rotateZ(360deg);\n    }\n`\n\nconst StyledButton = styled.button`\n    &:focus {\n        outline: none; \n    }\n    // Импортируем функцию анимации в свойство animation указывая сколько анимация будет длиться цикличность и плавность\n    &:hover {\n        animation: ${rotateAnimation} 1s infinite linear;\n    }\n\n`\n\nconst Button = (props) => {\n    return <StyledButton {...props}/>;\n};\n\nexport default Button;\n```",
        "message": "",
        "created": "2021-11-14T11:53:58.485Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "fc86cfd1-8ed7-436a-8042-085e3159d932",
      "emoji": null,
      "title": "О моделях в общем",
      "content": "",
      "headId": 1472733,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы",
      "parentFolderId": "1759d198-7c26-44f2-a484-4c59d6e29edb",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:29:40.669Z",
      "updatedAt": "2021-11-07T12:30:01.347Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472733,
        "docId": "fc86cfd1-8ed7-436a-8042-085e3159d932",
        "content": "\n# Model \n\n## Замечания\nКаждая запись модели должна быть однозначно идентифицируемой. Вы должны определить по крайней мере один из следующих атрибутов для каждой модели:\n\n- @unique\n- @@unique\n- @id\n- @@id\n## Соглашения об именах\nИмена моделей должны соответствовать следующему регулярному выражению: [A-Za-z][A-Za-z0-9_]*\nИмена моделей должны начинаться с буквы и обычно пишутся на языке PascalCase.\nВ названиях моделей следует использовать единственное число (например, Userвместо user, usersили Users).\nPrisma имеет ряд зарезервированных слов, которые используются Prisma внутри компании и поэтому не могут использоваться в качестве названия модели.\n\n## Примеры\nМодель User с двумя скалярными полями\n```\nmodel User {\n  email String  @unique // `email` не может быть необязательным, потому что это единственное уникальное поле в модели\n  name  String?\n}\n```\n\n# Поля моделей\nПоля  являются свойствами моделей.\n\n## Замечания\nСоглашения об именах\n- Должен начинаться с буквы\n- Обычно пишется в camelCase\n- Должно соответствовать следующему регулярному выражению: [A-Za-z][A-Za-z0-9_]*\n\n\n\n# модификаторы типа поля\n#### __[]__ -  модификатор\nДелает поле списком.\n\n### Замечания\nНе может быть необязательным (например Post[]?).\n### Реляционные базы данных\nСкалярные списки (массивы) поддерживаются в модели данных только в том случае, если ваша база данных поддерживает их изначально. Поэтому в настоящее время скалярные списки поддерживаются только при использовании PostgreSQL.\n\n## Примеры\n```\nmodel User {\n  id             Int      @id @default(autoincrement())\n  posts          Post[]\n  favoriteColors String[]\n}\n```\n\n#### __?__ модификатор\nДелает поле необязательным.\n\n### Замечания\nНе может использоваться с полем списка (например, Posts[])\nПримеры\nНеобязательное name поле\n```\nmodel User {\n  id   Int     @id @default(autoincrement())\n  name String?\n}\n```\n\n# Атрибуты\nАтрибуты изменяют поведение поля или блока (например, модели ). Есть два способа добавить атрибуты в вашу модель данных:\n- Атрибуты поля имеют префикс@\n- Атрибуты блока имеют префикс@@\n\nНекоторые атрибуты принимают аргументы. Аргументы в атрибутах всегда имеют имена, но в большинстве случаев имя аргумента можно опустить.\n\n## @id \nОпределяет идентификатор одного поля в модели.\n\n### Замечания\n- Не может быть определено в поле отношения\n- Не может быть необязательным\n- Соответствующий тип базы данных: PRIMARY KEY\n- Может быть аннотирован @default()значением, которое использует функции для автоматического создания идентификатора:\n\n  - autoincrement()\n  - cuid()\n  - uuid()\nМожет быть определен на любом поле скалярного типа ( String, Int, enum)\n\n## Примеры\nВ большинстве случаев когда вы хотите, чтобы ваша база данных создавала идентификатор. Надо аннотировать поле идентификатора @default атрибутом и инициализируйте поле функцией.\n\n```\nmodel User {\n  id   Int    @id @default(autoincrement())\n  name String\n}\n\nmodel User {\n  id   String @id @default(cuid())\n  name String\n}\n\nmodel User {\n  id   String @id @default(uuid())\n  name String\n}\n```\n\n## @unique\nОпределяет уникальное значение для этого поля.\n\n### Замечания\n- Поле с пометкой @unique может быть необязательным или обязательным.\n- Поле, помеченное значком, @unique должно быть обязательным, если оно представляет единственное уникальное ограничение в модели без символа @id или @@id\n- Модель может иметь любое количество уникальных ограничений.\n- Может быть определено на любом скалярном поле\n- Не может быть определено в поле отношения\n- NULL значения считаются разными (допускается несколько строк со NULL значениями в одном столбце)\n- Добавление ограничения уникальности автоматически добавляет соответствующий уникальный индекс к указанному столбцу (столбцам).\n\n### Примеры\nУкажите уникальный атрибут в обязательном String поле\n```\nmodel User {\n  email String @unique\n  name  String\n}\n```\nУкажите уникальный атрибут в необязательном String поле\n```\nmodel User {\n  id    Int     @id @default(autoincrement())\n  email String? @unique\n  name  String\n}\n```\n\nУкажите уникальный атрибут в скалярном поле отношения authorId\n```\nmodel Post {\n  author    User    @relation(fields: [authorId], references: [id])\n  authorId  Int     @unique\n  title     String\n  published Boolean @default(false)\n}\n```\n```\nmodel User {\n  id    Int     @id @default(autoincrement())\n  email String? @unique\n  name  String\n  Post  Post[]\n}\n```\nУкажите уникальный атрибут со cuid()значениями в качестве значений по умолчанию\n```\nmodel User {\n  token String @unique @default(cuid())\n  name  String\n}\n```\n",
        "message": "",
        "created": "2021-11-07T12:30:01.336Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "48f9e47a-eab3-469f-8962-82b232c44407",
      "emoji": null,
      "title": "Подключение",
      "content": "",
      "headId": 1472730,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы",
      "parentFolderId": "1759d198-7c26-44f2-a484-4c59d6e29edb",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:28:44.589Z",
      "updatedAt": "2021-11-07T12:29:10.491Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472730,
        "docId": "48f9e47a-eab3-469f-8962-82b232c44407",
        "content": "## datasource\nОпределяет источник данных в схеме Prisma.\n<table><thead><tr><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Имя</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Необходимый</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Тип</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Описание</font></font></th></tr></thead><tbody><tr><td><code class=\"inline-code\">provider</code></td><td><strong><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">да</font></font></strong></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">String ( </font></font><code class=\"inline-code\">postgresql</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">, </font></font><code class=\"inline-code\">mysql</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">, </font></font><code class=\"inline-code\">sqlite</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">, </font></font><code class=\"inline-code\">sqlserver</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">, </font></font><code class=\"inline-code\">mongodb</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">)</font></font></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Описывает, какие соединители источников данных использовать.</font></font></td></tr><tr><td><code class=\"inline-code\">url</code></td><td><strong><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">да</font></font></strong></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Строка (URL)</font></font></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">URL-адрес подключения, включая информацию для аутентификации. </font><font style=\"vertical-align: inherit;\">Большинство соединителей используют </font></font><a href=\"/docs/reference/database-reference/connection-urls#format\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">синтаксис, предоставленный базой данных</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\"> .</font></font></td></tr><tr><td><code class=\"inline-code\">shadowDatabaseUrl</code></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Нет</font></font></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Строка (URL)</font></font></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">URL-адрес подключения к теневой базе данных, используемой Prisma Migrate. </font><font style=\"vertical-align: inherit;\">Позволяет использовать базу данных, размещенную в облаке, в качестве теневой базы данных.</font></font></td></tr><tr><td><code class=\"inline-code\">referentialIntegrity</code></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Нет</font></font></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Строка ( </font></font><code class=\"inline-code\">foreignKeys</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">, </font></font><code class=\"inline-code\">prisma</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">)</font></font></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Позволяет установить </font></font><a href=\"/docs/concepts/components/prisma-schema/relations/referential-integrity\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">ссылочную целостность</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\"> .</font></font></td></tr></tbody></table>\n\n\n# Примеры\n## Указание источника данных PostgreSQL\nВ этом примере целевая база данных доступна со следующими учетными данными:\n\n- Пользователь: johndoe\n- Пароль: mypassword\n- Хозяин: localhost\n- Порт: 5432\n- Имя базы данных: mydb\n- Имя схемы: public\n\n\n ```\ndatasource db {\n  provider = \"postgresql\"\n  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public\"\n}\n```\n## Укажите источник данных PostgreSQL через переменную среды\nВ этом примере целевая база данных доступна со следующими учетными данными:\n\n- Пользователь: johndoe\n- Пароль: mypassword\n- Хозяин: localhost\n- Порт: 5432\n- Имя базы данных: mydb\n- Имя схемы: public\n \n```\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n```\nПри запуске команды Prisma CLI, которой требуется URL-адрес подключения к базе данных (например prisma generate), необходимо убедиться, что __DATABASE_URL__ указана в переменных среды.\n\nОдин из способов сделать это - создать __.env__ файл со следующим содержимым. Обратите внимание, что файл должен находиться в том же каталоге, что и ваш __schema.prisma__ файл, для автоматического подключения Prisma CLI.\n\n```\nDATABASE_URL=postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public\n```\n",
        "message": "",
        "created": "2021-11-07T12:29:10.458Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "61ba54ab-ebb0-4abf-bc55-d69d3685e4cd",
      "emoji": null,
      "title": "Unsupported",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:11:13.179Z",
      "updatedAt": "2021-11-07T12:28:21.083Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": null
    },
    {
      "id": "5a03ab5b-9ca3-488e-8346-3b22248549ad",
      "emoji": null,
      "title": "Bytes",
      "content": "",
      "headId": 1472715,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:11:01.118Z",
      "updatedAt": "2021-11-07T12:28:21.083Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472715,
        "docId": "5a03ab5b-9ca3-488e-8346-3b22248549ad",
        "content": "\n## Bytes \n<table><thead><tr><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственные типы баз данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th></tr></thead><tbody><tr><td><code class=\"inline-code\">bytea</code></td><td><code class=\"inline-code\">@db.ByteA</code></td></tr></tbody></table>\n",
        "message": "",
        "created": "2021-11-07T12:26:49.463Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "dd5e2a83-f83f-4743-8e78-327d833058d3",
      "emoji": null,
      "title": "Json",
      "content": "",
      "headId": 1472924,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:10:52.819Z",
      "updatedAt": "2021-11-07T13:16:40.213Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472924,
        "docId": "dd5e2a83-f83f-4743-8e78-327d833058d3",
        "content": "\n\n## Json\n<table><thead><tr><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственные типы баз данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Примечания</font></font></th></tr></thead><tbody><tr><td><code class=\"inline-code\">json</code></td><td><code class=\"inline-code\">@db.Json</code></td><td>текстовые данные JSON</td></tr><tr><td><code class=\"inline-code\">jsonb</code></td><td><code class=\"inline-code\">@db.JsonB</code></td><td>двоичные данные JSON, разобранные</td></tr></tbody></table>\n",
        "message": "",
        "created": "2021-11-07T13:16:40.156Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "8359cde5-e709-45b5-8493-c42325b91d8b",
      "emoji": null,
      "title": "DateTime",
      "content": "",
      "headId": 1472920,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:10:44.779Z",
      "updatedAt": "2021-11-07T13:16:11.597Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472920,
        "docId": "8359cde5-e709-45b5-8493-c42325b91d8b",
        "content": "\n## DateTime\n\n<table><thead><tr><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственные типы баз данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Примечания</font></font></th></tr></thead><tbody><tr><td><code class=\"inline-code\">timestamp</code></td><td><code class=\"inline-code\">@db.Timestamp(x)</code></td><td>дата и время (без часового пояса)</td></tr><tr><td><code class=\"inline-code\">timestamptz</code></td><td><code class=\"inline-code\">@db.Timestamptz(x)</code></td><td>\tдата и время с учётом часового пояса</td></tr><tr><td><code class=\"inline-code\">date</code></td><td><code class=\"inline-code\">@db.Date</code></td><td>календарная дата (год, месяц, день)</td></tr><tr><td><code class=\"inline-code\">time</code></td><td><code class=\"inline-code\">@db.Time(x)</code></td><td>время суток (без часового пояса)</td></tr><tr><td><code class=\"inline-code\">timetz</code></td><td><code class=\"inline-code\">@db.Timetz(x)</code></td><td>время суток с учётом часового пояса</td></tr></tbody></table>\n",
        "message": "",
        "created": "2021-11-07T13:16:11.380Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "9bec0a64-11e5-42bf-bbcb-e51407a18ac0",
      "emoji": null,
      "title": "Decimal",
      "content": "",
      "headId": 1472916,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:10:32.748Z",
      "updatedAt": "2021-11-07T13:15:03.809Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472916,
        "docId": "9bec0a64-11e5-42bf-bbcb-e51407a18ac0",
        "content": "\n\n## Decimal \n\n<table><thead><tr><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственные типы баз данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Примечания</font></font></th></tr></thead><tbody><tr><td><code class=\"inline-code\">decimal</code> <font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">|</font></font> <code class=\"inline-code\">numeric</code></td><td><code class=\"inline-code\">@db.Decimal(p, s)</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">†</font></font></td><td>вещественное число заданной точности</td></tr><tr><td><code class=\"inline-code\">money</code></td><td><code class=\"inline-code\">@db.Money</code></td><td>денежная сумма</td></tr></tbody></table>",
        "message": "",
        "created": "2021-11-07T13:15:03.781Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "ec5ba381-1378-478f-b0c6-215493eb5915",
      "emoji": null,
      "title": "Float",
      "content": "",
      "headId": 1472912,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:10:21.078Z",
      "updatedAt": "2021-11-07T13:14:30.199Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472912,
        "docId": "ec5ba381-1378-478f-b0c6-215493eb5915",
        "content": "\n## Float\n\n<table><thead><tr><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственные типы баз данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Примечания</font></font></th></tr></thead><tbody><tr><td><code class=\"inline-code\">double precision</code></td><td><code class=\"inline-code\">@db.DoublePrecision</code></td><td>число двойной точности с плавающей точкой (8 байт)</td></tr><tr><td><code class=\"inline-code\">real</code></td><td><code class=\"inline-code\">@db.Real</code></td><td>число одинарной точности с плавающей точкой (4 байта)</td></tr></tbody></table>",
        "message": "",
        "created": "2021-11-07T13:14:29.752Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "ec0e5dac-f427-4024-b2c6-475d6402d687",
      "emoji": null,
      "title": "BigInt",
      "content": "",
      "headId": 1472911,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:10:11.640Z",
      "updatedAt": "2021-11-07T13:13:51.892Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472911,
        "docId": "ec0e5dac-f427-4024-b2c6-475d6402d687",
        "content": "\n## BigInt\n\n<table><thead><tr><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственные типы баз данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Примечания</font></font></th></tr></thead><tbody><tr><td><code class=\"inline-code\">bigint</code> <font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">|</font></font> <code class=\"inline-code\">int8</code></td><td><code class=\"inline-code\">@db.BigInt</code></td><td>знаковое целое из 8 байт</td></tr><tr><td><code class=\"inline-code\">bigserial</code> <font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">|</font></font> <code class=\"inline-code\">serial8</code></td><td><code class=\"inline-code\">@db.BigInt @default(autoincrement())</code></td><td>восьмибайтное целое с автоувеличением</td></tr></tbody></table>\n",
        "message": "",
        "created": "2021-11-07T13:13:51.883Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f3095b40-ab07-4c9c-9af6-f4f5e92877bb",
      "emoji": null,
      "title": "Int",
      "content": "",
      "headId": 1472909,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:09:59.701Z",
      "updatedAt": "2021-11-07T13:13:20.986Z",
      "version": 6,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472909,
        "docId": "f3095b40-ab07-4c9c-9af6-f4f5e92877bb",
        "content": "\n## Int\n\n<table><thead><tr><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственные типы баз данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Примечания</font></font></th></tr></thead><tbody><tr><td><code class=\"inline-code\">integer</code> <font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">| </font><font style=\"vertical-align: inherit;\">,</font></font> <code class=\"inline-code\">int</code><font style=\"vertical-align: inherit;\"></font><code class=\"inline-code\">int4</code></td><td><code class=\"inline-code\">@db.Integer</code></td><td>знаковое четырёхбайтное целое</td></tr><tr><td><code class=\"inline-code\">smallint</code> <font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">|</font></font> <code class=\"inline-code\">int2</code></td><td><code class=\"inline-code\">@db.SmallInt</code></td><td>\tзнаковое двухбайтное целое</td></tr><tr><td><code class=\"inline-code\">smallserial</code> <font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">|</font></font> <code class=\"inline-code\">serial2</code></td><td><code class=\"inline-code\">@db.SmallInt @default(autoincrement())</code></td><td>двухбайтное целое с автоувеличением</td></tr><tr><td><code class=\"inline-code\">serial</code> <font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">|</font></font> <code class=\"inline-code\">serial4</code></td><td><code class=\"inline-code\">@db.Int @default(autoincrement())</code></td><td>четырёхбайтное целое с автоувеличением</td></tr><tr><td><code class=\"inline-code\">oid</code></td><td><code class=\"inline-code\">@db.Oid</code></td><td></td></tr></tbody></table>",
        "message": "",
        "created": "2021-11-07T13:13:19.613Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "05bd0b8f-2132-4b2f-a5da-fdd29f2329a0",
      "emoji": null,
      "title": "Boolean",
      "content": "",
      "headId": 1472904,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:09:49.495Z",
      "updatedAt": "2021-11-07T13:11:30.299Z",
      "version": 6,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472904,
        "docId": "05bd0b8f-2132-4b2f-a5da-fdd29f2329a0",
        "content": "\n## Boolean \n<table><thead><tr><th align=\"left\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственные типы баз данных</font></font></th><th align=\"left\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Примечания</font></font></th></tr></thead><tbody><tr><td align=\"left\"><code class=\"inline-code\">boolean</code></td><td align=\"left\"><code class=\"inline-code\">@db.Boolean</code></td><td>логическое значение (true/false)</td></tr></tbody></table>\n",
        "message": "",
        "created": "2021-11-07T13:11:29.446Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f0f91d71-1791-4b4b-b09f-57d7fe1db8b0",
      "emoji": null,
      "title": "String",
      "content": "",
      "headId": 1472901,
      "archivedAt": null,
      "folderPathname": "/Prisma/API Postgres схемы/Скалярные типы моделей",
      "parentFolderId": "b27d4707-0545-46ca-a356-b55d1c0571b1",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T12:09:35.264Z",
      "updatedAt": "2021-11-07T13:11:10.283Z",
      "version": 7,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472901,
        "docId": "f0f91d71-1791-4b4b-b09f-57d7fe1db8b0",
        "content": "## String\n\n<table><thead><tr><th align=\"left\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Собственный тип базы данных</font></font></th><th align=\"left\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Атрибут типа собственной базы данных</font></font></th><th><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Примечания</font></font></th></tr></thead><tbody><tr><td align=\"left\"><code class=\"inline-code\">text</code></td><td align=\"left\"><code class=\"inline-code\">@db.Text</code></td><td>текст неограниченной длины</td></tr><tr><td align=\"left\"><code class=\"inline-code\">char</code></td><td align=\"left\"><code class=\"inline-code\">@db.Char(x)</code></td><td>текст фиксированной длины (строка всегда имеет строго заданный размер)</td></tr><tr><td align=\"left\"><code class=\"inline-code\">varchar</code></td><td align=\"left\"><code class=\"inline-code\">@db.VarChar(n)</code></td><td>текст с ограничением по длине (максимальная длина строка может быть ограничена)</td></tr><tr><td align=\"left\"><code class=\"inline-code\">bit</code></td><td align=\"left\"><code class=\"inline-code\">@db.Bit(x)</code></td><td>битовая строка фиксированной длины</td></tr><tr><td align=\"left\"><code class=\"inline-code\">varbit</code></td><td align=\"left\"><code class=\"inline-code\">@db.VarBit</code></td><td>битовая строка переменной длины</td></tr><tr><td align=\"left\"><code class=\"inline-code\">uuid</code></td><td align=\"left\"><code class=\"inline-code\">@db.Uuid</code></td><td>универсальный уникальный идентификатор</td></tr><tr><td align=\"left\"><code class=\"inline-code\">xml</code></td><td align=\"left\"><code class=\"inline-code\">@db.Xml</code></td><td>XML-данные</td></tr><tr><td align=\"left\"><code class=\"inline-code\">inet</code></td><td align=\"left\"><code class=\"inline-code\">@db.Inet</code></td><td>адрес узла IPv4 или IPv6</td></tr><tr><td align=\"left\"><code class=\"inline-code\">citext</code></td><td align=\"left\"><code class=\"inline-code\">@db.Citext</code></td><td><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Доступно, только если </font></font><a href=\"/docs/concepts/components/prisma-schema/features-without-psl-equivalent#enable-extensions-for-native-database-functions\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">включено расширение Citext</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\"> .</font></font></td></tr></tbody></table>",
        "message": "",
        "created": "2021-11-07T13:11:10.237Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "87240588-a93a-4225-860b-39b8c935704d",
      "emoji": null,
      "title": "Один к многим",
      "content": "",
      "headId": 1472623,
      "archivedAt": null,
      "folderPathname": "/Prisma/Связи",
      "parentFolderId": "e635f1db-d2bb-459d-bbd3-e77e1d3e1271",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T11:41:39.392Z",
      "updatedAt": "2021-11-07T12:04:14.499Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472623,
        "docId": "87240588-a93a-4225-860b-39b8c935704d",
        "content": "Отношения «один ко многим» (1-n) относятся к отношениям, в которых одна запись на одной стороне отношения может быть связана с нулем или более записями на другой стороне. В следующем примере существует одно отношение 1-n между Userи Post:\n\n```\nmodel User {\n  id    Int    @id @default(autoincrement())\n  posts Post[]\n}\n\nmodel Post {\n  id       Int  @id @default(autoincrement())\n  author   User @relation(fields: [authorId], references: [id])\n  authorId Int\n}\n```\nЭто 1-n-отношение выражает следующее:\n\n- \"у пользователя может быть ноль или более сообщений\"\n- \"у сообщения всегда должен быть автор\"\n\n# Многополевые отношения в реляционных базах данных\n\nВ только реляционных базах данных , вы можете также определить это соотношение , используя идентификаторы многопрофильных :\n\n``` \nmodel User {\n  firstName String\n  lastName  String\n  post      Post[]\n\n  @@id([firstName, lastName])\n}\n\nmodel Post {\n  id              Int    @id @default(autoincrement())\n  author          User   @relation(fields: [authorFirstName, authorLastName], references: [firstName, lastName])\n  authorFirstName String // relation scalar field (used in the `@relation` attribute above)\n  authorLastName  String // relation scalar field (used in the `@relation` attribute above)\n}\n```\n\n# Обязательные и необязательные поля отношения в отношениях \"один ко многим\"\n1-n-отношение всегда имеет два поля отношений:\n\n\n- список поле отношение, которое не помечается@relation\n- аннотированные поля соотношения ( в том числе его соотношение скаляра)\nСторона списка отношения 1-n всегда обязательна. С другой стороны связи, аннотированное поле отношения и отношением скалярным могут либо одновременно быть необязательными, или как быть обязательными.\n\nВ следующем примере вы можете создать Postбез назначения User:\n\n```\nmodel User {\n  id    Int    @id @default(autoincrement())\n  posts Post[]\n}\n\nmodel Post {\n  id       Int   @id @default(autoincrement())\n  author   User? @relation(fields: [authorId], references: [id])\n  authorId Int?\n}\n```\nВ следующем примере вы должны назначить a User при создании Post:\n\n``\nmodel User {\n  id    Int    @id @default(autoincrement())\n  posts Post[]\n}\n\nmodel Post {\n  id       Int  @id @default(autoincrement())\n  author   User @relation(fields: [authorId], references: [id])\n  authorId Int\n}\n```\n",
        "message": "",
        "created": "2021-11-07T12:04:14.479Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "ecbadea5-243e-4c1f-84b3-f9b1fcea4cb0",
      "emoji": null,
      "title": "Многие ко многи",
      "content": "",
      "headId": 1472613,
      "archivedAt": null,
      "folderPathname": "/Prisma/Связи",
      "parentFolderId": "e635f1db-d2bb-459d-bbd3-e77e1d3e1271",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T11:41:23.694Z",
      "updatedAt": "2021-11-07T12:00:09.724Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472613,
        "docId": "ecbadea5-243e-4c1f-84b3-f9b1fcea4cb0",
        "content": "# Явные отношения \"многие ко многим\"\nВ явном отношении «многие ко многим» таблица отношений представлена ​​как модель в схеме Prisma и может использоваться в запросах. Явные отношения «многие ко многим» определяют три модели:\n\n- Две модели, имеющие отношение \"многие ко многим\", например, CategoryиPost\n- Одна модель, которая представляет таблицу отношений, такую ​​как CategoriesOnPosts(также иногда называемая JOIN , ссылка или сводная таблица) в базовой базе данных\n\n\nВ этом примере модель, представляющая таблицу отношений, определяет дополнительные поля, которые описывают отношение Post/ Category- кто назначил категорию ( assignedBy) и когда была назначена категория ( assignedAt):\n\n```\nmodel Post {\n  id         Int                 @id @default(autoincrement())\n  title      String\n  categories CategoriesOnPosts[]\n}\n\nmodel Category {\n  id    Int                 @id @default(autoincrement())\n  name  String\n  posts CategoriesOnPosts[]\n}\n\nmodel CategoriesOnPosts {\n  post       Post     @relation(fields: [postId], references: [id])\n  postId     Int // relation scalar field (used in the `@relation` attribute above)\n  category   Category @relation(fields: [categoryId], references: [id])\n  categoryId Int // relation scalar field (used in the `@relation` attribute above)\n  assignedAt DateTime @default(now())\n  assignedBy String\n\n  @@id([postId, categoryId])\n}\n```\n\n## Запрос явного \"многие-ко-многим\"\nВ следующем разделе показано, как запросить явное отношение «многие ко многим». Вы можете запросить модель отношения напрямую ( prisma.categoryOnPost(...)) или использовать вложенные запросы для перехода от Post-> CategoryOnPost-> Categoryили наоборот.\n\n### Следующий запрос:\n\n- Создает Post\n- Создает присвоение категории или CategoryToPost(назначено Бобом, назначено сегодня)\n- Создает новый Category\n``` js\nconst createCategory = await prisma.post.create({\n  data: {\n    title: 'How to be Bob',\n    categories: {\n      create: [\n        {\n          assignedBy: 'Bob',\n          assignedAt: new Date(),\n          category: {\n            create: {\n              name: 'New category',\n            },\n          },\n        },\n      ],\n    },\n  },\n})\n```\n\n### Следующий запрос:\n\n- Создает новый Post\n- Создает новое назначение категории или CategoryToPost\n- Связывает назначение категории с существующими категориями (с идентификаторами 9 и 22)\n\n``` js\nconst assignCategories = await prisma.post.create({\n  data: {\n    title: 'How to be Bob',\n    categories: {\n      create: [\n        {\n          assignedBy: 'Bob',\n          assignedAt: new Date(),\n          category: {\n            connect: {\n              id: 9,\n            },\n          },\n        },\n        {\n          assignedBy: 'Bob',\n          assignedAt: new Date(),\n          category: {\n            connect: {\n              id: 22,\n            },\n          },\n        },\n      ],\n    },\n  },\n})\n```\n## Следующий запрос\nВозвращает все Post записи, в которых хотя бы одно some назначение категории ( categories) ( ) относится к категории с именем \"New category\":\n\n``` js\nconst getPosts = await prisma.post.findMany({\n  where: {\n    categories: {\n      some: {\n        category: {\n          name: 'New Category',\n        },\n      },\n    },\n  },\n})\n\n```\n## Следующий запрос\nВозвращает все категории, в которых хотя бы один ( some) заголовок связанной Postзаписи содержит слова, \"Cool stuff\" а категория была назначена Бобом.\n\n``` js\nconst getAssignments = await prisma.category.findMany({\n  where: {\n    posts: {\n      some: {\n        assignedBy: 'Bob',\n        post: {\n          title: {\n            contains: 'Cool stuff',\n          },\n        },\n      },\n    },\n  },\n})\n```\n\n## Следующий запрос\nПолучает все CategoryOnPost записи о назначениях категорий ( ), которые были назначены \"Bob\"одной из 5 публикаций:\n\n``` JS\nconst getAssignments = await prisma.categoriesOnPosts.findMany({\n  where: {\n    assignedBy: 'Bob',\n    post: {\n      id: {\n        in: [9, 4, 10, 12, 22],\n      },\n    },\n  },\n})\n```",
        "message": "",
        "created": "2021-11-07T12:00:09.453Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f9981330-a2b8-45f8-9839-6e8f063e31c6",
      "emoji": null,
      "title": "Один к одному",
      "content": "",
      "headId": 1472644,
      "archivedAt": null,
      "folderPathname": "/Prisma/Связи",
      "parentFolderId": "e635f1db-d2bb-459d-bbd3-e77e1d3e1271",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T11:40:59.652Z",
      "updatedAt": "2021-11-07T12:09:00.875Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472644,
        "docId": "f9981330-a2b8-45f8-9839-6e8f063e31c6",
        "content": "Отношения «один к одному» (1–1) относятся к отношениям, в которых с обеих сторон отношения может быть соединено не более одной записи. В приведенном ниже примере существует одно отношение 1-1 между Userи Profile:\n\n```\nmodel User {\n  id      Int      @id @default(autoincrement())\n  profile Profile?\n}\n\nmodel Profile {\n  id     Int  @id @default(autoincrement())\n  user   User @relation(fields: [userId], references: [id])\n  userId Int // relation scalar field (used in the `@relation` attribute above)\n}\n```\nСкаляр userId отношения - это прямое представление внешнего ключа в базовой базе данных. Это отношение 1-1 выражает следующее:\n\n- «пользователь может иметь ноль или один профили» (потому что profileполе является необязательным на User)\n- \"профиль всегда должен быть связан с одним пользователем\"\n\n\nВ только реляционных базах данных , можно также определить использование идентификаторов многопрофильных для определения 1-1 соотношения:\n\n```\nmodel User {\n  firstName String\n  lastName  String\n  profile   Profile?\n\n  @@id([firstName, lastName])\n}\n\nmodel Profile {\n  id            Int    @id @default(autoincrement())\n  user          User   @relation(fields: [userFirstName, userLastName], references: [firstName, lastName])\n  userFirstName String // relation scalar field (used in the `@relation` attribute above)\n  userLastName  String // relation scalar field (used in the `@relation` attribute above)\n}\n```\n\n# Обязательные и необязательные поля отношения 1-1\nВо взаимно-однозначном отношении сторона отношения без скаляра отношения (поле, представляющее внешний ключ в базе данных) должна быть необязательной:\n```\nmodel User {\n  id      Int      @id @default(autoincrement())\n  profile Profile? // No relation scalar - must be optional\n}\n```\n\nОднако вы можете выбрать, должна ли сторона отношения со скаляром отношения быть необязательной или обязательной. В следующем примере profile и profileId являются обязательными. Это означает, что вы не можете создать, User не подключив или не создав Profile:\n```\nmodel User {\n  id        Int     @id @default(autoincrement())\n  profile   Profile @relation(fields: [profileId], references: [id]) // references `id` of `Profile`\n  profileId Int // relation scalar field (used in the `@relation` attribute above)\n}\n\nmodel Profile {\n  id   Int   @id @default(autoincrement())\n  user User?\n}\n```\nВ следующем примере profile и profileId являются необязательными. Это означает, что вы можете создать пользователя без подключения или создания Profile:\n```\nmodel User {\n  id        Int      @id @default(autoincrement())\n  profile   Profile? @relation(fields: [profileId], references: [id]) // references `id` of `Profile`\n  profileId Int? // relation scalar field (used in the `@relation` attribute above)\n}\n\nmodel Profile {\n  id   Int   @id @default(autoincrement())\n  user User?\n}\n```\n# Выбор стороны, которая должна хранить внешний ключ в соотношении 1-1\n\nВ отношениях 1-1 вы можете сами решить, какую сторону отношения вы хотите аннотировать с помощью @relation атрибута (и, следовательно, удерживать внешний ключ).\n\nВ следующем примере поле отношения в Profile модели аннотируется @relation атрибутом. userId является прямым представлением внешнего ключа в базовой базе данных:\n```\nmodel User {\n  id      Int      @id @default(autoincrement())\n  profile Profile?\n}\n\nmodel Profile {\n  id     Int  @id @default(autoincrement())\n  user   User @relation(fields: [userId], references: [id])\n  userId Int // relation scalar field (used in the `@relation` attribute above)\n}\n```\nВы также можете аннотировать другую сторону отношения с помощью @relation атрибута. В следующем примере аннотируется поле отношения в User модели. profileId является прямым представлением внешнего ключа в базовой базе данных:\n```\nmodel User {\n  id        Int      @id @default(autoincrement())\n  profile   Profile? @relation(fields: [profileId], references: [id])\n  profileId Int? // relation scalar field (used in the `@relation` attribute above)\n}\n\nmodel Profile {\n  id   Int   @id @default(autoincrement())\n  user User?\n}\n```",
        "message": "",
        "created": "2021-11-07T12:09:00.811Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "fd8287e0-cf64-49e9-8648-150ee635c5ca",
      "emoji": null,
      "title": "Схемы призмы",
      "content": "",
      "headId": 1472316,
      "archivedAt": null,
      "folderPathname": "/Prisma",
      "parentFolderId": "a2a684e5-6943-4ac5-b9ed-85fa4b63795d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T10:18:40.879Z",
      "updatedAt": "2021-11-07T10:22:15.923Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472316,
        "docId": "fd8287e0-cf64-49e9-8648-150ee635c5ca",
        "content": "# Схема призмы\nФайл схемы Prisma (сокращенно: файл схемы , схема Prisma или схема ) является основным файлом конфигурации для вашей установки Prisma. Обычно он называется schema.prismaи состоит из следующих частей:\n\n- Источники данных : укажите детали источников данных, к которым должна подключаться Prisma (например, база данных PostgreSQL).\n- Генераторы : указывает, какие клиенты должны быть созданы на основе модели данных (например, Prisma Client).\n- Определение модели данных : указывает модели вашего приложения(форма данных для каждого источника данных) и их отношения.\n\nКаждый раз, когда prisma вызывается команда, интерфейс командной строки обычно считывает некоторую информацию из файла схемы, например:\n\n - ```prisma generate```: Считывает всю вышеупомянутую информацию из схемы Prisma для создания правильного клиентского кода источника данных (например, Prisma Client).\n\n - ```prisma migrate dev```: Считывает источники данных и определение модели данных для создания новой миграции.\nВы также можете использовать переменные среды внутри файла схемы для предоставления параметров конфигурации при вызове команды CLI.\n\n\n# Пример\nНиже приведен пример файла схемы Prisma, который определяет:\n\n- Источник данных (PostgreSQL или MongoDB)\n- Генератор (Prisma Client)\n- Определение модели данных с двумя моделями (с одним отношением) и одним enum\n- Несколько атрибутов собственных типов данных ( @db.VarChar(255), @db.ObjectId)\n\n``` js\ndatasource db {\n  url      = env(\"DATABASE_URL\")\n  provider = \"postgresql\"\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n  email     String   @unique\n  name      String?\n  role      Role     @default(USER)\n  posts     Post[]\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  published Boolean  @default(false)\n  title     String   @db.VarChar(255)\n  author    User?    @relation(fields: [authorId], references: [id])\n  authorId  Int?\n}\n\nenum Role {\n  USER\n  ADMIN\n}\n```\n\n# Именование\nИмя по умолчанию для файла схемы schema.prisma. Когда ваш файл схемы имеет такое имя, Prisma CLI автоматически обнаружит его в каталоге, в котором вы вызываете команду CLI (или в любом из его подкаталогов).\n\nЕсли файл имеет другое имя, вы можете предоставить --schema аргумент CLI Prisma с путем к файлу схемы, например:\n```\nprisma generate --schema ./database/myschema.prisma\n```",
        "message": "",
        "created": "2021-11-07T10:22:15.747Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "47debeac-a537-4086-9b7a-5cc0d6d7b9dc",
      "emoji": null,
      "title": "Prisma migrate",
      "content": "",
      "headId": 1472202,
      "archivedAt": null,
      "folderPathname": "/Prisma",
      "parentFolderId": "a2a684e5-6943-4ac5-b9ed-85fa4b63795d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-07T09:46:51.530Z",
      "updatedAt": "2021-11-07T09:55:37.615Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1472202,
        "docId": "47debeac-a537-4086-9b7a-5cc0d6d7b9dc",
        "content": "# Миграция схемы с помощью Prisma Migrate\nСегодня мы рады поделиться новой версией Prisma Migrate! 🎊\n\nPrisma Migrate - это инструмент моделирования и миграции данных, который упрощает развитие схемы базы данных с приложением в тандеме. Миграция основана на схеме Prisma - декларативном определении модели данных, который кодифицирует вашу схему базы данных.\n\nЭтот предварительный выпуск является развитием экспериментальной версии Migrate, выпущенной нами в прошлом году. С тех пор мы собираем отзывы сообщества и включаем их в Prisma Migrate.\n\n# Интеграция с Prisma Client\nPrisma Migrate интегрируется с Prisma Client, используя схему Prisma в качестве общего источника истины. Другими словами, и Prisma Client, и миграции генерируются на основе схемы Prisma. Это упрощает синхронизацию и проверку изменений схемы базы данных в коде вашего приложения за счет использования безопасности типов Prisma Client.\n\n# Как работает Prisma Migrate?\nPrisma Migrate основан на схеме Prisma и работает путем создания .sqlфайлов миграции, которые выполняются для вашей базы данных.\n\nСхема Prisma является отправной точкой для миграции схемы и обеспечивает обзор желаемого конечного состояния базы данных. Prisma Migrate проверяет изменения в схеме Prisma и генерирует необходимые .sql файлы миграции для применения.\n\nПрименение миграций выглядит по-разному в зависимости от стадии разработки. Например, во время разработки существуют сценарии, в которых сброс базы данных допустим для более быстрого прототипирования, в то время как в производственной среде необходимо проявлять большую осторожность, чтобы избежать потери данных и поломки изменений.\n\nPrisma Migrate учитывает это с помощью рабочих процессов для локальной разработки и применения миграций в производственной среде.\n\n# Развитие схемы в процессе разработки\nВо время разработки вы сначала определяете схему Prisma, а затем запускаете prisma migrate dev --preview-featureкоманду, которая генерирует миграцию, применяет ее и генерирует Prisma Client:\n\nРабочий процесс разработки\n![2020-12-migrate-development-workflow.png](https://boostnote.io/api/teams/nhFMY3a5g/files/285d53c0e0d318b2763773dd392d37d7bb8ed383962656164568050692436682-2020-12-migrate-development-workflow.png)\n\n\n\nВот пример, показывающий это в действии:\n\n1. Определите желаемую схему базы данных, используя схему Prisma:\n``` \ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id    Int      @id @default(autoincrement())\n  name  String\n  posts Post[]\n}\n\nmodel Post {\n  id        Int     @id @default(autoincrement())\n  title     String\n  published Boolean @default(true)\n  authorId  Int\n  author    User    @relation(fields: [authorId], references: [id])\n}\n```\n2. Запустите, ```prisma migrate dev --preview-feature``` чтобы создать и выполнить миграцию.\n\n\nРазверните, чтобы просмотреть содержимое SQL сгенерированной миграции.\nПосле выполнения миграции файлы миграции обычно фиксируются в репозитории, чтобы миграцию можно было применить в других средах.\n\nДальнейшие изменения схемы базы данных следуют тому же рабочему процессу и начинаются с обновления схемы Prisma.\n\n# Настройка миграции SQL\nВы можете настроить SQL-запрос миграции с помощью следующего рабочего процесса:\n\nВыполните, ```prisma migrate dev --create-only --preview-feature``` чтобы создать миграцию SQL, не применяя ее.\nОтредактируйте SQL-запрос миграции.\nЗапустите, ```prisma migrate dev --preview-feature``` чтобы применить.\n\n# Применение миграций в производственной и других средах\n\nЧтобы применить миграции к другим средам, таким как производственная среда, вы извлекаете изменения в репозиторий, содержащий миграции, и запускаете ```prisma migrate deploy``` команду:\n![2020-12-migrate-production-workflow.png](https://boostnote.io/api/teams/nhFMY3a5g/files/df0aa9c58c5a3ce60d0a90db084300d548fd45e72da97eb51ea7d6883565a2cb-2020-12-migrate-production-workflow.png)\n",
        "message": "",
        "created": "2021-11-07T09:55:37.443Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "1bb4fa82-3ade-4f3f-be41-102d88ccb22a",
      "emoji": null,
      "title": "Разворачивание проекта",
      "content": "",
      "headId": 1470474,
      "archivedAt": null,
      "folderPathname": "/Nest-Prisma-template",
      "parentFolderId": "966441c0-7a90-453f-b559-c3b723c275c6",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-11-06T21:15:33.705Z",
      "updatedAt": "2021-11-06T21:24:12.430Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1470474,
        "docId": "1bb4fa82-3ade-4f3f-be41-102d88ccb22a",
        "content": "### 1. Install Dependencies\n\nУстановка [Nestjs CLI](https://docs.nestjs.com/cli/usages) для запуска и генерации ресурсов CRUD [генерации ресурсов CRUD](https://trilon.io/blog/introducing-cli-generators-crud-api-in-1-minute)\n\n```bash\nnpm i -g @nestjs/cli\n```\n\nУстановите зависимости для приложения Nest:\n\n```bash\nnpm install\n```\n\n### 2. PostgreSQL с Docker\n\nНастройте разработку PostgreSQL с помощью Docker. Копируйте __.env.example__  и переименуйте в  `.env`. Обновите переменные по своему усмотрению.\n\nРазверните контейнер БД\n```bash\ndocker-compose -f docker-compose.db.yml up -d\n# or\nnpm run docker:db\n```\n\n### 3. Prisma Migrate\n\nPrisma Migrate используется для управления схемой и миграцией базы данных. Для источника данных Prisma требуется переменная среды `DATABASE_URL` для подключения к базе данных PostgreSQL. Prisma читает `DATABASE_URL` из файла  __.env__\n\nUse Prisma Migrate in your [development environment](https://www.prisma.io/blog/prisma-migrate-preview-b5eno5g08d0b#evolving-the-schema-in-development) to\n\n1. Creates `migration.sql` file\n2. Updates Database Schema\n3. Generates Prisma Client\n\n```bash\nnpx prisma migrate dev\n# or\nnpm run migrate:dev\n```\n\nIf you like to customize your `migration.sql` file run the following command. After making your customizations run `npx prisma migrate dev` to apply it.\n\n```bash\nnpx prisma migrate dev --create-only\n# or\nnpm run migrate:dev:create\n```\n\nIf you are happy with your database changes you want to deploy those changes to your [production database](https://www.prisma.io/blog/prisma-migrate-preview-b5eno5g08d0b#applying-migrations-in-production-and-other-environments). Use `prisma migrate deploy` to apply all pending migrations, can also be used in CI/CD pipelines as it works without prompts.\n\n```bash\nnpx prisma migrate deploy\n# or\nnpm run migrate:deploy\n```\n\n### 4. Prisma: Prisma Client JS\n\n[Prisma Client JS](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/api) is a type-safe database client auto-generated based on the data model.\n\nGenerate Prisma Client JS by running\n\n> **Note**: Every time you update [schema.prisma](prisma/schema.prisma) re-generate Prisma Client JS\n\n```bash\nnpx prisma generate\n# or\nnpm run prisma:generate\n```\n\n### 5. Seed the database data with this script\n\nExecute the script with this command:\n\n```bash\nnpm run seed\n```\n\n### 6. Start NestJS Server\n\nRun Nest Server in Development mode:\n\n```bash\nnpm run start\n\n# watch mode\nnpm run start:dev\n```\n\nRun Nest Server in Production mode:\n\n```bash\nnpm run start:prod\n```\n\nGraphQL Playground for the NestJS Server is available here: http://localhost:3000/graphql\n\n**[⬆ back to top](#overview)**\n\n## GraphQL Playground\n\nOpen up the [example GraphQL queries](graphql/auth.graphql) and copy them to the GraphQL Playground. Some queries and mutations are secured by an auth guard. You have to acquire a JWT token from `signup` or `login`. Add the `accessToken`as followed to **HTTP HEADERS** in the playground and replace `YOURTOKEN` here:\n\n```json\n{\n  \"Authorization\": \"Bearer YOURTOKEN\"\n}\n```\n\n## Rest Api\n\n[RESTful API](http://localhost:3000/api) documentation available with Swagger.\n\n## Docker\n\nNest server is a Node.js application and it is easily [dockerized](https://nodejs.org/de/docs/guides/nodejs-docker-webapp/).\n\nSee the [Dockerfile](./Dockerfile) on how to build a Docker image of your Nest server.\n\nNow to build a Docker image of your own Nest server simply run:\n\n```bash\n# give your docker image a name\ndocker build -t <your username>/nest-prisma-server .\n# for example\ndocker build -t nest-prisma-server .\n```\n\nAfter Docker build your docker image you are ready to start up a docker container running the nest server:\n\n```bash\ndocker run -d -t -p 3000:3000 --env-file .env nest-prisma-server\n```\n\nNow open up [localhost:3000](http://localhost:3000) to verify that your nest server is running.\n\nWhen you run your NestJS application in a Docker container update your [.env](.env) file\n\n```diff\n- DB_HOST=localhost\n# replace with name of the database container\n+ DB_HOST=postgres\n\n# Prisma database connection\n+ DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${DB_HOST}:${DB_PORT}/${POSTGRES_DB}?schema=${DB_SCHEMA}&sslmode=prefer\n```\n\nIf `DATABASE_URL` is missing in the root `.env` file, which is loaded into the Docker container, the NestJS application will exit with the following error:\n\n```bash\n(node:19) UnhandledPromiseRejectionWarning: Error: error: Environment variable not found: DATABASE_URL.\n  -->  schema.prisma:3\n   |\n 2 |   provider = \"postgresql\"\n 3 |   url      = env(\"DATABASE_URL\")\n```\n\n### Docker Compose\n\nYou can also setup a the database and Nest application with the docker-compose\n\n```bash\n# building new NestJS docker image\ndocker-compose build\n# or\nnpm run docker:build\n\n# start docker-compose\ndocker-compose up -d\n# or\nnpm run docker\n```\n\n## Schema Development\n\nUpdate the Prisma schema `prisma/schema.prisma` and after that run the following two commands:\n\n```bash\nnpx prisma generate\n# or in watch mode\nnpx prisma generate --watch\n# or\nnpm run prisma:generate\nnpm run prisma:generate:watch\n```\n\n**[⬆ back to top](#overview)**\n\n## NestJS - Api Schema\n\nThe [schema.graphql](./src/schema.graphql) is generated with [code first approach](https://docs.nestjs.com/graphql/quick-start#code-first). The schema is generated from the [models](./src/models/user.ts), the [resolvers](./src/resolvers/auth/auth.resolver.ts) and the [input](./src/resolvers/auth/dto/login.input.ts) classes.\n\nYou can use [class-validator](https://docs.nestjs.com/techniques/validation) to validate your inputs and arguments.\n\n### Resolver\n\nTo implement the new query, a new resolver function needs to be added to `users.resolver.ts`.\n\n```ts\n@Query(returns => User)\nasync getUser(@Args() args): Promise<User> {\n  return await this.prisma.client.user(args);\n}\n```\n\nRestart the NestJS server and this time the Query to fetch a `user` should work.\n\n**[⬆ back to top](#overview)**\n\n## GraphQL Client\n\nA GraphQL client is necessary to consume the GraphQL api provided by the NestJS Server.\n\nCheckout [Apollo](https://www.apollographql.com/) a popular GraphQL client which offers several clients for React, Angular, Vue.js, Native iOS, Native Android and more.\n\n### Angular\n\n#### Setup\n\nTo start using [Apollo Angular](https://www.apollographql.com/docs/angular/basics/setup.html) simply run in an Angular and Ionic project:\n\n```bash\nng add apollo-angular\n```\n\n`HttpLink` from apollo-angular requires the `HttpClient`. Therefore, you need to add the `HttpClientModule` to the `AppModule`:\n\n```ts\nimports: [BrowserModule,\n    HttpClientModule,\n    ...,\n    GraphQLModule],\n```\n\nYou can also add the `GraphQLModule` in the `AppModule` to make `Apollo` available in your Angular App.\n\nYou need to set the URL to the NestJS GraphQL Api. Open the file `src/app/graphql.module.ts` and update `uri`:\n\n```ts\nconst uri = 'http://localhost:3000/graphql';\n```\n\nTo use Apollo-Angular you can inject `private apollo: Apollo` into the constructor of a page, component or service.\n\n**[⬆ back to top](#overview)**\n\n#### Queries\n\nTo execute a query you can use:\n\n```ts\nthis.apollo.query({query: YOUR_QUERY});\n\n# or\n\nthis.apollo.watchQuery({\n  query: YOUR_QUERY\n}).valueChanges;\n```\n\nHere is an example how to fetch your profile from the NestJS GraphQL Api:\n\n```ts\nconst CurrentUserProfile = gql`\n  query CurrentUserProfile {\n    me {\n      id\n      email\n      name\n    }\n  }\n`;\n\n@Component({\n  selector: 'app-home',\n  templateUrl: 'home.page.html',\n  styleUrls: ['home.page.scss'],\n})\nexport class HomePage implements OnInit {\n  data: Observable<any>;\n\n  constructor(private apollo: Apollo) {}\n\n  ngOnInit() {\n    this.data = this.apollo.watchQuery({\n      query: CurrentUserProfile,\n    }).valueChanges;\n  }\n}\n```\n\nUse the `AsyncPipe` and [SelectPipe](https://www.apollographql.com/docs/angular/basics/queries.html#select-pipe) to unwrap the data Observable in the template:\n\n```html\n<div *ngIf=\"data | async | select: 'me' as me\">\n  <p>Me id: {{me.id}}</p>\n  <p>Me email: {{me.email}}</p>\n  <p>Me name: {{me.name}}</p>\n</div>\n```\n\nOr unwrap the data using [RxJs](https://www.apollographql.com/docs/angular/basics/queries.html#rxjs).\n\nThis will end up in an `GraphQL error` because `Me` is protected by an `@UseGuards(GqlAuthGuard)` and requires an `Bearer TOKEN`.\nPlease refer to the [Authentication](#authentication) section.\n\n**[⬆ back to top](#overview)**\n\n#### Mutations\n\nTo execute a mutation you can use:\n\n```ts\nthis.apollo.mutate({\n  mutation: YOUR_MUTATION,\n});\n```\n\nHere is an example how to login into your profile using the `login` Mutation:\n\n```ts\nconst Login = gql`\n  mutation Login {\n    login(email: \"test@example.com\", password: \"pizzaHawaii\") {\n      token\n      user {\n        id\n        email\n        name\n      }\n    }\n  }\n`;\n\n@Component({\n  selector: 'app-home',\n  templateUrl: 'home.page.html',\n  styleUrls: ['home.page.scss'],\n})\nexport class HomePage implements OnInit {\n  data: Observable<any>;\n\n  constructor(private apollo: Apollo) {}\n\n  ngOnInit() {\n    this.data = this.apollo.mutate({\n      mutation: Login,\n    });\n  }\n}\n```\n\n**[⬆ back to top](#overview)**\n\n#### Subscriptions\n\nTo execute a subscription you can use:\n\n```ts\nthis.apollo.subscribe({\n  query: YOUR_SUBSCRIPTION_QUERY,\n});\n```\n\n**[⬆ back to top](#overview)**\n\n#### Authentication\n\nTo authenticate your requests you have to add your `TOKEN` you receive on `signup` and `login` [mutation](#mutations) to each request which is protected by the `@UseGuards(GqlAuthGuard)`.\n\nBecause the apollo client is using `HttpClient` under the hood you are able to simply use an `Interceptor` to add your token to the requests.\n\nCreate the following class:\n\n```ts\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class TokenInterceptor implements HttpInterceptor {\n  constructor() {}\n\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const token = 'YOUR_TOKEN'; // get from local storage\n    if (token !== undefined) {\n      req = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n    }\n\n    return next.handle(req);\n  }\n}\n```\n\nAdd the Interceptor to the `AppModule` providers like this:\n\n```ts\nproviders: [\n    ...\n    { provide: HTTP_INTERCEPTORS, useClass: TokenInterceptor, multi: true },\n    ...\n  ]\n```\n\nAfter you configured the Interceptor and retrieved the `TOKEN` from storage your request will succeed on resolvers with `@UseGuards(GqlAuthGuard)`.\n\n**[⬆ back to top](#overview)**\n",
        "message": "",
        "created": "2021-11-06T21:24:12.419Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "c2633bda-c40c-4940-ae88-ddb0fe01f3e6",
      "emoji": null,
      "title": "Поиск",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:56:53.807Z",
      "updatedAt": "2021-10-26T14:56:53.807Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "10b3e519-6743-4e71-a31e-442bb6f64cc0",
      "emoji": null,
      "title": "Теги",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:54:43.719Z",
      "updatedAt": "2021-10-26T14:54:43.719Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "3c32347e-d3d3-4cc1-a8f5-c353b57ba565",
      "emoji": null,
      "title": "Создание аудиозаписей и текста под диктовку",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:46:40.796Z",
      "updatedAt": "2021-10-26T14:46:40.796Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "4700f006-95f7-471c-ac9a-ebb6e48cd4a8",
      "emoji": null,
      "title": "Блокнот с OneNote",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:44:51.226Z",
      "updatedAt": "2021-10-26T14:44:51.226Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "0a8c23eb-b960-4258-b5bc-2027a451856f",
      "emoji": null,
      "title": "Цветовые и иконочные схемы",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:42:28.101Z",
      "updatedAt": "2021-10-26T14:42:28.101Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "08bcc624-ed5d-40f9-a717-d3872aa6bfcf",
      "emoji": null,
      "title": "Блок-схемы",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:41:50.614Z",
      "updatedAt": "2021-10-26T14:41:50.614Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "48d95ee5-c379-4e77-98bc-0f1f2861f73b",
      "emoji": null,
      "title": "Шаблон для истемейта",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:41:13.545Z",
      "updatedAt": "2021-10-26T14:41:13.545Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "d99a30d3-9191-4d04-bc2e-395a463db37e",
      "emoji": null,
      "title": "Рисование пером",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:40:45.301Z",
      "updatedAt": "2021-10-26T14:40:45.301Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "4159b31c-268a-4cbd-a348-7df78c1c46d1",
      "emoji": null,
      "title": "Рукописный ввод",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MyNote/Функционал",
      "parentFolderId": "20c52980-6f6b-496d-8e5d-aa8ffb717717",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-26T14:40:32.013Z",
      "updatedAt": "2021-10-26T14:40:32.013Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "a3ba4302-14de-41f9-8feb-be571dc27e53",
      "emoji": null,
      "title": "Связывание",
      "content": "",
      "headId": 1393317,
      "archivedAt": null,
      "folderPathname": "/MyNote",
      "parentFolderId": "78d8fe07-cb7d-4dd6-8d80-885bf60dd0b6",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-23T05:46:12.302Z",
      "updatedAt": "2021-10-23T05:46:59.519Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1393317,
        "docId": "a3ba4302-14de-41f9-8feb-be571dc27e53",
        "content": "1. Текст\n2. Блок-схемы\n3. Файлы",
        "message": "",
        "created": "2021-10-23T05:46:59.494Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "5b25a4a5-0c99-4889-886f-cbe19b1eb3d8",
      "emoji": null,
      "title": "Добавить от себя",
      "content": "",
      "headId": 1393308,
      "archivedAt": null,
      "folderPathname": "/MyNote",
      "parentFolderId": "78d8fe07-cb7d-4dd6-8d80-885bf60dd0b6",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-23T05:43:56.629Z",
      "updatedAt": "2021-10-23T05:45:56.933Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1393308,
        "docId": "5b25a4a5-0c99-4889-886f-cbe19b1eb3d8",
        "content": "1. Цветовая схема по умолчанию.\n2. Добавление блок-схем\n3. Гибкое создание кодовых блоков и связывание этого дела с блок-схемами",
        "message": "",
        "created": "2021-10-23T05:45:56.923Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "2a506554-f91e-486c-b2ba-0ff317cbfc7a",
      "emoji": null,
      "title": "BoostNote",
      "content": "",
      "headId": 1393303,
      "archivedAt": null,
      "folderPathname": "/MyNote/Что перенять из",
      "parentFolderId": "34b3478e-04bc-45ce-b97e-276564c2a902",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-23T05:37:29.317Z",
      "updatedAt": "2021-10-23T05:41:55.734Z",
      "version": 6,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1393303,
        "docId": "2a506554-f91e-486c-b2ba-0ff317cbfc7a",
        "content": "В общем Boost Note отличный редактор функционал которого можно перенять на первое время. Убрав лишнее и добавив свое.",
        "message": "",
        "created": "2021-10-23T05:41:55.726Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "9c064a5f-0df3-4558-8168-769895dfabe3",
      "emoji": null,
      "title": "Typora",
      "content": "",
      "headId": 1393294,
      "archivedAt": null,
      "folderPathname": "/MyNote/Что перенять из",
      "parentFolderId": "34b3478e-04bc-45ce-b97e-276564c2a902",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-23T05:34:55.688Z",
      "updatedAt": "2021-10-23T05:37:31.965Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1393294,
        "docId": "9c064a5f-0df3-4558-8168-769895dfabe3",
        "content": "1. Режим полноэкранного текстового редактора, в этом режиме текстовое полотно становиться во весь экран приложения убирая прочий интерфейс.",
        "message": "",
        "created": "2021-10-23T05:37:31.952Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "65cef3af-4062-44f3-87d7-7715188a5985",
      "emoji": null,
      "title": "Паттерн приватного роута",
      "content": "",
      "headId": 1383391,
      "archivedAt": null,
      "folderPathname": "/React/Apollo/Паттерны",
      "parentFolderId": "cb0b4d9f-a748-4aa2-aaa8-a4c6de30f7cd",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-21T08:37:52.444Z",
      "updatedAt": "2021-10-21T08:39:22.127Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1383391,
        "docId": "65cef3af-4062-44f3-87d7-7715188a5985",
        "content": "``` js\nconst IS_LOGGED_IN = gql`\n  {\n    isLoggedIn @client \n  }\n`\n\nconst Pages = () => {\n  return (\n    <Router>\n      <Layout>\n        <Route exact path=\"/\" component={Home}/>\n        <PrivateRoute path=\"/mynotes\" component={MyNotes}/>\n        <PrivateRoute path=\"/favorites\" component={Favorites}/>\n        <Route path=\"/note/:id\" component={NotePage}/>\n        <Route path=\"/signup\" component={SignUp}/>\n        <Route path=\"/signin\" component={SignIn} />\n      </Layout>\n    </Router>\n  )\n}\n\nconst PrivateRoute = ({component: Component, ...rest}) => {\n  const {loading, error, data} = useQuery(IS_LOGGED_IN)\n  // Если данные загружаются, выводим сообщение о загрузке\n  if (loading) return <p>Loading...</p>;\n// Если при получении данных произошел сбой, выводим сообщение об ошибке\n  if (error) return <p>Error!</p>;\n// Если пользователь авторизован, направляем его к запрашиваемому компоненту\n// В противном случае перенаправляем на страницу авторизации\n  return (\n    <Route {...rest}\n      render={props =>\n        data.isLoggedIn === true ? (\n          <Component {...props}/>\n        ): (\n          <Redirect to={{\n            pathname: '/signin',\n            state: {from: props.location}\n          }}\n          />\n        )\n      }\n    />\n  )\n}\n```\n\nКогда мы переадресуем приватный маршрут, мы также сохраняем соответ-\nствующий ему URL как состояние. Это позволяет перенаправлять пользова-\nтелей обратно на страницу, на которую они пытались перейти изначально. Мы\nможем обновить переадресацию на страницу авторизации, чтобы при необхо-\nдимости активировать эту функцию с помощью props.state.location.from .",
        "message": "",
        "created": "2021-10-21T08:39:22.119Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "283706c6-5e94-42cc-95d6-77d3521f6af1",
      "emoji": null,
      "title": "Запись данных в кеш",
      "content": "",
      "headId": 1383254,
      "archivedAt": null,
      "folderPathname": "/React/Apollo",
      "parentFolderId": "917eb315-1d9e-4a59-8923-1813b06e6ef5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-20T18:15:26.334Z",
      "updatedAt": "2021-10-21T08:13:08.330Z",
      "version": 6,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1383254,
        "docId": "283706c6-5e94-42cc-95d6-77d3521f6af1",
        "content": "1. Что бы иметь возможность делать запросы к кешу надо добавить в конфигурацию ApolloClient пустой объект resolvers как показано ниже.\n\n``` js\nconst client = new ApolloClient({\nlink: authLink.concat(httpLink),\ncache,\nresolvers: {},\nconnectToDevTools: true\n});\n```\n\n2. После что бы записать данные в кеш необходимо использовать метод client.writeData() на подобии примера снизу.\n\n``` js\nconst client = useApolloClient();\nclient.writeData({ data: { isLoggedIn: true } });\n```\n\nочень желательно делать запись в __data__\n\n3. Для изъятия данных с кеша необходимо обратиться к нему через вот такой запрос \n\n``` js\nconst IS_LOGGED_IN = gql`\n  {\n    isLogged @client\n  }\n`\n```\n\nГде сначала указываем свойство которое ходим достать, а после пишем директиву __@client__ чем даем понять что нам необходимо достать данные исключительно из кеша\n\n\nПосле делаем обычный запрос через useQuery\n\n``` js\nconst {data, client} = useQuery(IS_LOGGED_IN)\n```\n\n4. Так же можно обрабатывать данные в кеше в момент инициализаци. Вот пример\n\n``` js\n/ Настраиваем Apollo Client\nconst client = new ApolloClient({\n  link: authLink.concat(httpLink),\n  uri,\n  cache,\n  resolvers: {},\n  connectToDevTools: true\n})\n\n// Проверяем наличие локального токена\nconst data = {\n  isLoggedIn: !!localStorage.getItem('token')\n}\n// Записываем данные кэша при начальной загрузке\ncache.writeData({data})\n// Записываем данные кэша после его сброса\nclient.onResetStore(() => cache.writeData({data}))\n\nconst App = () => {\n  return(\n    <ApolloProvider client={client}>\n      <GlobalStyle/>\n      <Pages/>\n    </ApolloProvider>\n  )\n}\n```",
        "message": "",
        "created": "2021-10-21T08:13:08.310Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "cac1bd6c-6668-49b8-a110-371797d68cda",
      "emoji": null,
      "title": "Регистрация на Apollo",
      "content": "",
      "headId": 1378982,
      "archivedAt": null,
      "folderPathname": "/React/Apollo",
      "parentFolderId": "917eb315-1d9e-4a59-8923-1813b06e6ef5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-20T14:40:43.708Z",
      "updatedAt": "2021-10-20T14:42:19.681Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1378982,
        "docId": "cac1bd6c-6668-49b8-a110-371797d68cda",
        "content": "``` js\nconst SignUp = props => {\n  const [values, setValues] = useState();\n\n  const onChange = event => {\n    setValues({\n      ...values,\n    [event.target.name]: event.target.value\n    })\n  }\n\n  const [signUp, {loading, error}] = useMutation(SIGNUP_USER, {\n    onCompleted: data => {\n      localStorage.setItem('token', data.signUp);\n      // Редирект на домашнюю страницу\n      props.history.push('/');\n    }\n  })\n\n  return (\n    <Wrapper>\n      <Form\n      onSubmit={event => {\n        event.preventDefault();\n        signUp({\n          variables: {\n            ...values\n          }\n        })\n      }}\n      >\n        <label htmlFor=\"username\">Username:</label>\n        <input\n          required\n          type=\"text\"\n          id=\"username\"\n          name=\"username\"\n          placeholder=\"username\"\n          onChange={onChange}\n        />\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          required\n          type=\"email\"\n          id=\"email\"\n          name=\"email\"\n          placeholder=\"Email\"\n          onChange={onChange}\n        />\n        <label htmlFor=\"password\">Password:</label>\n        <input\n          required\n          type=\"password\"\n          id=\"password\"\n          name=\"password\"\n          placeholder=\"Password\"\n          onChange={onChange}\n        />\n        <Button type=\"submit\">Submit</Button>\n      </Form>\n    </Wrapper>\n  );\n};\n```",
        "message": "",
        "created": "2021-10-20T14:42:19.671Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "fdc81bbf-bdb9-4eab-9b14-e4ece034631e",
      "emoji": null,
      "title": "Универсальный обрапотчик значений компаонентов форм",
      "content": "",
      "headId": 1378979,
      "archivedAt": null,
      "folderPathname": "/React/Полезные фичи",
      "parentFolderId": "c6484bea-b2af-4ec6-acc0-8711f7ea8942",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-20T14:36:32.263Z",
      "updatedAt": "2021-10-20T14:40:28.959Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1378979,
        "docId": "fdc81bbf-bdb9-4eab-9b14-e4ece034631e",
        "content": "Фишка этого обработчика состоит в том что мне больше не обязательно пложить куча состояний для инпутов и прочих. Достаточно одногой состояния, одной функции обработчик и дать имена инпутам в соответсвии с данными которые готовится принять api\n\nПример:\n``` js\n  const [values, setValues] = useState();\n\n  const onChange = event => {\n    setValues({\n      ...values,\n    [event.target.name]: event.target.value\n    })\n  }\n  \n  return (\n    <Wrapper>\n      <Form\n      onSubmit={event => {\n        event.preventDefault();\n        signUp({\n          variables: {\n            ...values\n          }\n        })\n      }}\n      >\n        <label htmlFor=\"username\">Username:</label>\n        <input\n          required\n          type=\"text\"\n          id=\"username\"\n          name=\"username\"\n          placeholder=\"username\"\n          onChange={onChange}\n        />\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          required\n          type=\"email\"\n          id=\"email\"\n          name=\"email\"\n          placeholder=\"Email\"\n          onChange={onChange}\n        />\n        <label htmlFor=\"password\">Password:</label>\n        <input\n          required\n          type=\"password\"\n          id=\"password\"\n          name=\"password\"\n          placeholder=\"Password\"\n          onChange={onChange}\n        />\n        <Button type=\"submit\">Submit</Button>\n      </Form>\n    </Wrapper>\n  );\n};\n```\n\n",
        "message": "",
        "created": "2021-10-20T14:40:28.947Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f07e0f9c-55d8-4fe9-88ca-0579dff7df6d",
      "emoji": null,
      "title": "FetchMore pagination",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/React/Apollo",
      "parentFolderId": "917eb315-1d9e-4a59-8923-1813b06e6ef5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-20T13:00:29.032Z",
      "updatedAt": "2021-10-20T13:00:29.032Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": null
    },
    {
      "id": "43443cc1-342f-442d-91df-ab7636a4c3d9",
      "emoji": null,
      "title": "Дата и время",
      "content": "",
      "headId": 1337714,
      "archivedAt": null,
      "folderPathname": "/",
      "parentFolderId": null,
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-13T17:38:50.485Z",
      "updatedAt": "2021-10-13T17:41:18.435Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "11279ac2-ffa0-4af9-a881-97601ea0fb70",
      "head": {
        "id": 1337714,
        "docId": "43443cc1-342f-442d-91df-ab7636a4c3d9",
        "content": "Давайте обновим нашу GraphQL-схему в файле src/schema.js , добавив пользовательский скаляр в верхнюю часть строкового литерала \n``` js\nmodule.exports = gql`\n  scalar DateTime\n...\n`;\n```\nТеперь добавьте в тип Note поля createdAt и updatedAt :\n``` js\ntype Note {\n  id: ID!\n  content: String!\n  author: String!\n  createdAt: DateTime!\n  updatedAt: DateTime!\n}\n```\nПоследним шагом будет проверка этого нового типа. Хотя мы и можем прописать\nсобственную проверку, в данном случае мы будем использовать пакет graphql-iso-date ( https://oreil.ly/CtmP6 ). Для этого мы добавим проверку во все функции\nраспознавания, запрашивающие значения с типом DateTime .\nИмпортируйте этот пакет в файл src/resolvers/index.js и добавьте значение DateTime\nв экспортированные распознаватели:\n``` js\nconst Query = require('./query');\nconst Mutation = require('./mutation');\nconst { GraphQLDateTime } = require('graphql-iso-date');\nmodule.exports = {\nQuery,\nMutation,\nDateTime: GraphQLDateTime\n};\n```\nЕсли теперь перейти на GraphQL Playground и обновить страницу, то можно\nпроверить, работают ли наши пользовательские типы, как планировалось. Если\nобратиться к схеме, то можно увидеть, что поля createdAt и updatedAt имеют\nтип DateTime . Как показано на рис. 6.1, документация для этого типа сообщает,\nчто он является «строкой даты и времени в формате UTC».\nЧтобы все это проверить, давайте напишем на площадке GraphQL мутацию\nnewNote , включающую поля даты:\n``` js\nmutation {\n  newNote (content: \"This is a note with a custom type!\") {\n  content\n  author\n  id\n  createdAt\n  updatedAt\n  }\n}\n```",
        "message": "",
        "created": "2021-10-13T17:41:18.426Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "5c8e48f2-4f45-49ea-9d2f-c68ad5c2fe1f",
      "emoji": null,
      "title": "Рецепт проброса ключа",
      "content": "",
      "headId": 1334436,
      "archivedAt": null,
      "folderPathname": "/SSH",
      "parentFolderId": "0033d178-c55a-457e-bb3f-bade91d8ea4b",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-13T08:33:22.042Z",
      "updatedAt": "2021-10-13T08:33:49.097Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1334436,
        "docId": "5c8e48f2-4f45-49ea-9d2f-c68ad5c2fe1f",
        "content": "Для инстркуции перейди сюды [https://jeka.by/ask/182/ssh-without-password/#answer-79](url)",
        "message": "",
        "created": "2021-10-13T08:33:49.089Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "5046c593-8d71-4854-bff4-bb614deb3fee",
      "emoji": null,
      "title": "Обновление токенов access + refresh",
      "content": "",
      "headId": 1318835,
      "archivedAt": null,
      "folderPathname": "/React/Apollo",
      "parentFolderId": "917eb315-1d9e-4a59-8923-1813b06e6ef5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-11T06:18:12.230Z",
      "updatedAt": "2021-10-11T06:19:47.408Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1318835,
        "docId": "5046c593-8d71-4854-bff4-bb614deb3fee",
        "content": "``` js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  ApolloClient,\n  ApolloProvider,\n  HttpLink,\n  InMemoryCache,\n  fromPromise,\n  ApolloLink\n} from \"@apollo/client\";\n// Apps\nimport {App} from './app/App'\nimport {MetronicI18nProvider} from './_metronic/i18n/Metronici18n'\n\n/**\n * TIP: Replace this style import with dark styles to enable dark mode\n *\n * import './_metronic/assets/sass/style.dark.scss'\n **/\nimport './_metronic/assets/sass/style.scss'\nimport {setContext} from \"@apollo/client/link/context\";\nimport {onError} from \"@apollo/client/link/error\";\nimport {REFRESH_TOKEN} from \"./apollo/apollo/queries/authAdmin\";\n\n/**\n * Base URL of the website.\n *\n * @see https://facebook.github.io/create-react-app/docs/using-the-public-folder\n */\nconst {PUBLIC_URL} = process.env\n\n\n// Init Apollo================\n\nlet client: ApolloClient<any>\nconst httpLink = new HttpLink({uri: 'https://retter-local.dev-test.pro/graphql'})\n\nconst withTokenLink = setContext((_, {headers}) => {\n  const token = localStorage.getItem('admin_access_token');\n  return {\n    headers: {\n      ...headers,\n      authorization: token ? `Bearer ${token}` : \"\",\n    }\n  }\n});\n\ninterface IRefreshResponse {\n  refreshToken: {\n    refreshToken: string\n    accessToken: string\n  }\n\n  [key: string]: any\n}\n\nconst getNewTokenPair = () => {\n  const refreshToken = localStorage.getItem('admin_refresh_token')\n  return client.mutate({mutation: REFRESH_TOKEN, variables: {refreshToken}})\n    .then((data) => {\n      console.log('DATA', data)\n      if (data.data) {\n        return data.data?.refreshToken;\n      }\n    })\n    .catch(err => {\n      console.log('$$$>>', err)\n      // return\n    });\n};\n\nconst tokenErrorLink = onError(\n  ({graphQLErrors, networkError, operation, forward}) => {\n    if (graphQLErrors) {\n      for (let err of graphQLErrors) {\n        if (err.message === 'Access token error: jwt expired') {\n          return fromPromise(\n            getNewTokenPair().catch((error) => {\n              console.log('from getNewTokenPair>> ', error)\n              return;\n            })\n          )\n            .filter((data = {}) => Boolean(data?.accessToken) && Boolean(data?.refreshToken))\n            .flatMap(({accessToken, refreshToken}) => {\n              const oldHeaders = operation.getContext().headers;\n              operation.setContext({\n                headers: {\n                  ...oldHeaders,\n                  authorization: `Bearer ${accessToken}`,\n                },\n              });\n\n              localStorage.setItem('admin_access_token', accessToken)\n              localStorage.setItem('admin_refresh_token', refreshToken)\n\n              return forward(operation);\n            });\n        }\n      }\n    }\n  }\n);\n\nclient = new ApolloClient({\n  link: ApolloLink.from([tokenErrorLink, withTokenLink, httpLink]),\n  cache: new InMemoryCache()\n});\n\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <MetronicI18nProvider>\n      <App basename={PUBLIC_URL}/>\n    </MetronicI18nProvider>\n  </ApolloProvider>,\n  document.getElementById('root')\n)\n```",
        "message": "",
        "created": "2021-10-11T06:19:47.395Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "c96dd519-5aad-4c38-a297-04fd5d508762",
      "emoji": null,
      "title": "Контекст",
      "content": "",
      "headId": 1316772,
      "archivedAt": null,
      "folderPathname": "/",
      "parentFolderId": null,
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-10T18:45:52.779Z",
      "updatedAt": "2021-10-10T18:51:18.530Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "11279ac2-ffa0-4af9-a881-97601ea0fb70",
      "head": {
        "id": 1316772,
        "docId": "c96dd519-5aad-4c38-a297-04fd5d508762",
        "content": "Контекст позволяет нам при каждом запросе передавать конкретную информацию из кода сервера в отдельный\nраспознаватель.\n\nК примеру сейчас мы передадим туда перед запросом модели, которые нам нужны в распознавателях для работы с БД. \n\n1. В файле инициализации сервера (обычно это корневой index.js) при инициализации ApolloServer передаем в контекст то что нам надо (сейчас модель)\n\n``` js\n// Настройка Apollo Server\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context: () => {\n  // Добавление моделей БД в context\n  return { models };\n  }\n});\n```\n\n2. После содержимого контекста мы можем вызвать 3-им аргументом в распознавателях \n\n```js\nnotes: async (parent, args, { models }) => {\n  return await models.Note.find()\n},\n```",
        "message": "",
        "created": "2021-10-10T18:51:18.508Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "7ca8d6fe-1b27-4392-aa2d-3c818c41cec8",
      "emoji": null,
      "title": "Код для подключения БД",
      "content": "",
      "headId": 1316317,
      "archivedAt": null,
      "folderPathname": "/MongoDB",
      "parentFolderId": "509409fc-0cb8-4aa4-9c3e-868b053fc28d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-10T16:12:57.435Z",
      "updatedAt": "2021-10-10T16:17:21.360Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1316317,
        "docId": "7ca8d6fe-1b27-4392-aa2d-3c818c41cec8",
        "content": "Сначала нам понадобится обновить файл .env , добавив URL локальной базы\nданных. Это позволит нам указывать URL БД в любой рабочей среде (например, в локальной разработке и в производстве). По умолчанию URL локального\nсервера MongoDB следующий: mongodb://localhost:27017 . К нему мы и добавим\nимя нашей базы данных. Итак, в файле .env определим переменную DB_HOST\nс URL экземпляра БД Mongo таким образом:\n```\nDB_HOST=mongodb://localhost:27017/notedly\n```\nСледующим шагом будет подключение базы данных к приложению. Давайте на-\nпишем код, который будет выполнять это подключение при запуске приложения.\nДля этого сначала создадим в директории src файл db.js . В нем мы пропишем\nкод для подключения БД, а также добавим функцию close для закрытия этого\nподключения, что пригодится при тестировании приложения.\nВ src/db.js введите:\n```\n// Затребуем библиотеку mongoose\nconst mongoose = require('mongoose');\nmodule.exports = {\n  connect: DB_HOST => {\n  // Используем обновленный парсер строки URL драйвера Mongo\n  mongoose.set('useNewUrlParser', true);\n  // Поставим findOneAndUpdate () вместо findAndModify ()\n  mongoose.set('useFindAndModify', false);\n  // Поставим createIndex () вместо sureIndex ()\n  mongoose.set('useCreateIndex', true);\n  // Используем новый механизм обнаружения и мониторинга серверов\n  mongoose.set('useUnifiedTopology', true);\n  // Подключаемся к БД\n  mongoose.connect(DB_HOST);\n  // Выводим ошибку при неуспешном подключении\n  mongoose.connection.on('error', err => {\n  console.error(err);\n  console.log(\n  'MongoDB connection error. Please make sure MongoDB is running.'\n  );\n  process.exit();\n  });\n  },\n  close: () => {\n    mongoose.connection.close();\n  }\n};\n```\nТеперь обновим src/index.js для вызова этого подключения. Чтобы это сделать,\nсначала импортируем конфигурацию .env , а также файл db.js . В начале импортируемых файлов введите следующее:\n```\nrequire('dotenv').config();\nconst db = require('./db');\n```\nМне нравится хранить значение DB_HOST, определенное в файле .env , в виде\nпеременной. Добавьте эту переменную сразу под определением переменной port :\n```\nconst DB_HOST = process.env.DB_HOST;\n```\nЗатем мы можем вызвать подключение, добавив в файл src/index.js следующее:\n```\ndb.connect(DB_HOST);\n```",
        "message": "",
        "created": "2021-10-10T16:17:21.344Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "5552584e-8711-4a32-a885-7f359e0b0f2a",
      "emoji": null,
      "title": "Основные команды",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/MongoDB/Работа в консоли",
      "parentFolderId": "cf2e31dd-93d9-466d-a279-36446298f547",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-10T15:57:20.195Z",
      "updatedAt": "2021-10-10T15:57:20.195Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": null
    },
    {
      "id": "41c736ea-5ac6-4a0d-a19a-da000516e545",
      "emoji": null,
      "title": "Параметры функции распознавателя",
      "content": "",
      "headId": 1315262,
      "archivedAt": null,
      "folderPathname": "/",
      "parentFolderId": null,
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-10T10:10:34.911Z",
      "updatedAt": "2021-10-10T10:12:28.686Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "11279ac2-ffa0-4af9-a881-97601ea0fb70",
      "head": {
        "id": 1315262,
        "docId": "41c736ea-5ac6-4a0d-a19a-da000516e545",
        "content": "Apollo Server передает\nфункциям распознавания следующие полезные параметры:\n1. __parent__ -\nРезультат родительского запроса, который полезен при вложении запросов.\n2. __args__ -\nАргументы, передаваемые пользователем в запросе.\n3. __context__ -\nИнформация, которая передается от серверного приложения функциям распознавания и может включать, к примеру, данные о текущем пользователе\nили интересующее нас содержимое БД.\n4. __info__ -\nИнформация о самом запросе.",
        "message": "",
        "created": "2021-10-10T10:12:28.677Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "4b1aacf9-ee05-404a-bd8a-4d517a35ecc4",
      "emoji": null,
      "title": "Концепция приложения",
      "content": "",
      "headId": 1313593,
      "archivedAt": null,
      "folderPathname": "/MyNote",
      "parentFolderId": "78d8fe07-cb7d-4dd6-8d80-885bf60dd0b6",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-09T18:08:51.173Z",
      "updatedAt": "2021-10-09T18:10:35.657Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1313593,
        "docId": "4b1aacf9-ee05-404a-bd8a-4d517a35ecc4",
        "content": "Концепция приложения путем грамотной визуализации облегчить понимание кода. \n\n",
        "message": "",
        "created": "2021-10-09T18:10:35.648Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "d8911328-4a7d-4d09-bd71-0d45a209dc87",
      "emoji": null,
      "title": "Заметки",
      "content": "",
      "headId": 1309260,
      "archivedAt": null,
      "folderPathname": "/MyNote",
      "parentFolderId": "78d8fe07-cb7d-4dd6-8d80-885bf60dd0b6",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-08T13:52:10.104Z",
      "updatedAt": "2021-10-08T13:55:19.151Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1309260,
        "docId": "d8911328-4a7d-4d09-bd71-0d45a209dc87",
        "content": "1. Система коментарий и код\n\n    Надо организовать грамотную структуру написание кода и коментария.\n    с возможностью убирать то или тто и таким образом или остаеться чистый код состоящий из коментариев илибо человекопонятным языком объяснение что здесь в общем происходит с возможностью убрать все это дело",
        "message": "",
        "created": "2021-10-08T13:55:19.144Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "4c81f3c4-6a18-47b2-bbf2-2ca4ad014cb2",
      "emoji": null,
      "title": "BasicController",
      "content": "",
      "headId": 1308737,
      "archivedAt": null,
      "folderPathname": "/SCH/Controllers",
      "parentFolderId": "f2c03ef3-0021-4244-ac9f-1682fcefaac6",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-08T11:57:00.422Z",
      "updatedAt": "2021-10-08T11:58:06.476Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1308737,
        "docId": "4c81f3c4-6a18-47b2-bbf2-2ca4ad014cb2",
        "content": "Родительский класс для всех контроллеров ",
        "message": "",
        "created": "2021-10-08T11:58:06.468Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "1592bfa3-7098-433f-8f13-49be5e444632",
      "emoji": null,
      "title": "Методы бота",
      "content": "",
      "headId": 1272788,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию/События",
      "parentFolderId": "3c169270-63d7-436c-a50e-061d2419a381",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-02T15:47:50.671Z",
      "updatedAt": "2021-10-02T15:48:31.791Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1272788,
        "docId": "1592bfa3-7098-433f-8f13-49be5e444632",
        "content": "``` js\n\n```",
        "message": "",
        "created": "2021-10-02T15:48:31.783Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "453c4e36-2476-4cff-bce8-503173d2f28e",
      "emoji": null,
      "title": "Список действий бота",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию/События",
      "parentFolderId": "3c169270-63d7-436c-a50e-061d2419a381",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-02T15:25:32.891Z",
      "updatedAt": "2021-10-02T15:25:32.891Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "37d4a61d-b0eb-4248-a236-f360de4734ef",
      "emoji": null,
      "title": "Вынос событий в отдельную функцию",
      "content": "",
      "headId": 1272705,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию/События",
      "parentFolderId": "3c169270-63d7-436c-a50e-061d2419a381",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-02T15:18:14.047Z",
      "updatedAt": "2021-10-02T15:20:50.949Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1272705,
        "docId": "37d4a61d-b0eb-4248-a236-f360de4734ef",
        "content": "События можно выносить в отдельные функции как показано ниже, а затем пропихивать их в обработчик\n\n``` js\n// Достаем кнопки из отдельного модуля\nconst {gameOptions} = require(\"./options.js\");\n\nconst startGame = async (chatId, bot, chats) => {\n    await bot.sendMessage(chatId, 'Я сейчас загадаю цифру от 0 до 9, а ты должен ее отгадать!')\n    chats[chatId] = Math.floor(Math.random() * 10)\n    // Так же функция sendMessage третьим аргументом принимает кнопки которые конечно надо\n    // создать заранне и пример создания кнопок я описываю выше\n    await bot.sendMessage(chatId, 'Отгадывай', gameOptions)\n}\n\nmodule.exports = startGame\n```\n\nПример использования в обработчике\n\n``` js\n  if (text === '/game') {\n      return startGame(chatId, bot, chats)\n  }\n```",
        "message": "",
        "created": "2021-10-02T15:20:50.942Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "3a4d14e0-afce-4e12-b95e-3901f173f5e2",
      "emoji": null,
      "title": "Создание кнопок",
      "content": "",
      "headId": 1272698,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию/События",
      "parentFolderId": "3c169270-63d7-436c-a50e-061d2419a381",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-02T15:14:27.658Z",
      "updatedAt": "2021-10-02T15:18:13.556Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1272698,
        "docId": "3a4d14e0-afce-4e12-b95e-3901f173f5e2",
        "content": "В папке __assets__ создаем файл __options.js__ в нем мы будем создавать кнопки. По следующему примеру \n\n```js\n// Кнопки\nmodule.exports = {\n     gameOptions: {\n        reply_markup: JSON.stringify({\n            inline_keyboard: [\n                // Это массив с самим кнопками состоящий из названий и значений кнопок, и так же можно управлять количеством\n                // кнопок в ряду\n                [{text: '1', callback_data: '1'}, {text: '2', callback_data: '2'}, {text: '3', callback_data: '3'}],\n                [{text: '4', callback_data: '4'}, {text: '5', callback_data: '5'}, {text: '6', callback_data: '6'}],\n                [{text: '7', callback_data: '7'}, {text: '8', callback_data: '8'}, {text: '9', callback_data: '9'}],\n                [{text: '0', callback_data: '0'}]\n            ]\n        })\n    },\n\n     againOptions: {\n        reply_markup: JSON.stringify({\n            inline_keyboard: [\n                [{text: 'Играть еще раз', callback_data: '/again'}]\n            ]\n        })\n    }\n}\n```\n\nДля того что бы вывести эти кнопки необходимо передать их в метод __sendMessage__ третьим аргументом\n\n``` js\nawait bot.sendMessage(chatId, 'Отгадывай', gameOptions)\n```",
        "message": "",
        "created": "2021-10-02T15:18:13.548Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "540d92bf-0392-40d6-89ce-3c845eb56388",
      "emoji": null,
      "title": "Создание слушателя кнопочных запросов",
      "content": "",
      "headId": 1272719,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию/События",
      "parentFolderId": "3c169270-63d7-436c-a50e-061d2419a381",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-02T15:09:12.984Z",
      "updatedAt": "2021-10-02T15:25:36.020Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1272719,
        "docId": "540d92bf-0392-40d6-89ce-3c845eb56388",
        "content": "По сути обработчик событий возврата кнопочных значений не сильно отличается от обработчика сообщений просто если первый следит за тем что вы пишите боту то второй следит за тем какие кнопки нажимаете\n\nСоздаем это дело в папке __events__ в файле __query.js__\n``` js\n// Импортируем модель пользователя\nconst UserModel = require(\"../db/models\");\n// Достаем кнопки из отдельного модуля\nconst {againOptions} = require(\"../assets/options.js\");\nconst startGame = require('../assets/startGame')\n\n\nconst query = (bot, chats) => {\n    // А это обработчик который перехватывает ответы от кнопок\n    bot.on('callback_query', async msg => {\n        const data = msg.data\n        const chatId = msg.message.chat.id\n        if (data === '/again') {\n            return startGame(chatId, bot, chats)\n        }\n        const user = await UserModel.findOne({chatId})\n\n        if (data == chats[chatId]) {\n            // Таким опбразом мы меняем запис в бд\n            user.right += 1\n            await bot.sendMessage(chatId, `Поздравляю ты отгадал цифру ${chats[chatId]}`, againOptions)\n        } else {\n            // Таким опбразом мы меняем запис в бд\n            user.wrong += 1\n            await bot.sendMessage(chatId, `К сожалению ты не отгадал, бот загадал цифру ${chats[chatId]}`, againOptions)\n        }\n        // И после сохраняем изменния\n        await user.save()\n    })\n}\n\nmodule.exports = query\n```\n\nИ импортируем и разворачиваем это дело в __index.js__ \n\n``` js\nconst query = require('./events/query')\n//...\nquery(bot, chats)\n```",
        "message": "",
        "created": "2021-10-02T15:25:36.009Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "a3c54f04-46ef-45f1-b4d1-93bb4b7ff3ff",
      "emoji": null,
      "title": "Добавление команд в меню быстрого доступа",
      "content": "",
      "headId": 1272619,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию/События",
      "parentFolderId": "3c169270-63d7-436c-a50e-061d2419a381",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-02T14:56:22.011Z",
      "updatedAt": "2021-10-02T15:12:34.547Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1272619,
        "docId": "a3c54f04-46ef-45f1-b4d1-93bb4b7ff3ff",
        "content": "Для того что бы команда к боту отображалась в меню быстрого доступа ее необходимо добавить в список команд следующим образом.\n\n1. В папке __assets__ создаем файл __commandsList.js__\n2. И предаем ему следующий вид\n``` js\nconst commandsList = (bot) => {\n    // Для того что бы команды выводились в кнопку быстрого доступа их необходимо\n    // прописать в вот такой функции принимающию в себя массив этих команд\n    bot.setMyCommands([\n        {command: '/start', description: 'Начально приветствие'},\n        {command: '/info', description: 'Получить информацию о пользователе'},\n        {command: '/game', description: 'ИГра угадай цифру'}\n    ])\n}\n\nmodule.exports = commandsList\n```\n\nКак видим тут все просто надо только указать саму команду и описание к ней.\n\n3. Импортируем модуль в index.js  и там его разворачиваем\n\n``` js\nconst bot = new TelegramApi(token, {polling: true})\n\n// Импортруем и активируем функцию инициализирубщую команды для бота\nconst commandsList = require('./assets/commandsList')\ncommandsList(bot)\n// =================================================================\n```",
        "message": "",
        "created": "2021-10-02T14:58:42.935Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "20d69e17-dc45-4d21-bcac-d4f12281e314",
      "emoji": null,
      "title": "Создание слушаетля сообщения",
      "content": "",
      "headId": 1272681,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию/События",
      "parentFolderId": "3c169270-63d7-436c-a50e-061d2419a381",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-02T14:48:48.326Z",
      "updatedAt": "2021-10-02T15:13:58.016Z",
      "version": 7,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1272681,
        "docId": "20d69e17-dc45-4d21-bcac-d4f12281e314",
        "content": "События создаются в отдельном файле в папке __events__ в файле именуемым в честь событий за которыми следит обработчик событий к примеру сейчас тут разберем обработчик который вешается на события __message__ соответственно и файл будет называться __message.js__\n\n``` js\n// Импортируем модель пользователя\nconst UserModel = require(\"../db/models\");\nconst startGame = require('../assets/startGame')\n\nconst message = (bot, chats) => {\n    // Вешаем слушаетль на событие сообщения (прослушиваем то что нам пишут)\n    // callback функция предоставляет нам в качестве аргумента объект с данными\n    // в виде самого сообщения а так же информации о дате отправки и отправляюшем\n    bot.on('message', async msg => {\n        // Здесь мы настраиваем боты что бы он мог ответить на входящие сообщение\n        // Для этого нам необходимо достать id чата\n        const text = msg.text\n        const chatId = msg.chat.id\n\n        try {\n\n            // Таким образом мы можем настроить команды на которые бот будет отвечать\n            // определенным образом. Самое главное не забывать слеш так как команды\n            // принято начинать именно с него\n            if (text === '/start') {\n                // Как только новый пользователь заходит в чат создаем его запись в БД\n                await UserModel.create({chatId})\n                // Таким макаром можно отправлять стикеры сначала id чата, а после ссылка на стикер (только смотри\n                // что бы они были в формате webp)\n                await bot.sendSticker(chatId, 'https://tlgrm.ru/_/stickers/ea5/382/ea53826d-c192-376a-b766-e5abc535f1c9/7.webp')\n                // Далее используя функцию ниже мы пердаем в нее id чата\n                // что бы бот понимал кому отвечает и сообщение которое он\n                // отправляет\n                return bot.sendMessage(chatId, `Добро пожаловать!`)\n                // Так же есть подобные функции для отправки картинок аудио и других форматов\n                // надо только посомтреть в доке\n            }\n\n            if (text === '/info') {\n                // Для вывода данных о пользователе находим его в БД и ложим в константу\n                const user = await UserModel.findOne({chatId})\n                return bot.sendMessage(chatId, `Тебя зовут ${msg.chat.first_name}, в итоге у тебя правильных ответов ${user.right}, неправильных ${user.wrong}`)\n            }\n\n            if (text === '/game') {\n                return startGame(chatId, bot, chats)\n            }\n            // Это сообщение будет отправляться когда ниодна из команд выше не подойдет под запрос\n            return bot.sendMessage(chatId, `Я тебя не понимаю поробуй еще раз!`)\n        } catch (e) {\n            return bot.sendMessage(chatId, 'Произошла какая то ошибочка!)')\n        }\n    })\n}\n\nmodule.exports = message\n```\n\nПосле импортируем этот модуль в index.js\n\n``` js\nconst message = require('./events/message')\n//...\nmessage(bot, chats)\n```",
        "message": "",
        "created": "2021-10-02T15:13:58.009Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "3fe69f72-3053-4630-8c8b-dc147ec64cee",
      "emoji": null,
      "title": "Инициализация бота",
      "content": "",
      "headId": 1272581,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию",
      "parentFolderId": "1f174df0-ae1f-4017-b4e1-c2ab26a22ba2",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-02T14:41:16.861Z",
      "updatedAt": "2021-10-02T14:48:33.304Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1272581,
        "docId": "3fe69f72-3053-4630-8c8b-dc147ec64cee",
        "content": "1. Выполняем в корне проекта команду\n```\nnpm init -y\n```\n2. А затем \n``` \nnpm i node-telegram-bot-api nodemon\n```\n\n3. После создаем в корне файл index.js и предаем ему следующий вид\n\n``` js\n// Импортируем зависимость для настройки нашего бота\nconst TelegramApi = require('node-telegram-bot-api')\n// Константа хранящая токен бота\nconst token = '2042137493:AAHIHxhD8c1dF7u3DjpQTvpESOaleQpRsp0'\n// Инициализируем самого бота передавая в класс токен и так же конфигурации\nconst bot = new TelegramApi(token, {polling: true})\n```\n\n4. Идем в packeg.json и настраиваем там команды для разработки и деплоя\n\n``` js\n  \"scripts\": {\n    \"dev\": \"nodemon index.js\",\n    \"start\": \"node index.js\"\n  },\n```\n",
        "message": "",
        "created": "2021-10-02T14:48:33.295Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "5a6e0fc5-675d-4fc2-b873-9eef2eb1fb37",
      "emoji": null,
      "title": "Структура",
      "content": "",
      "headId": 1272556,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию",
      "parentFolderId": "1f174df0-ae1f-4017-b4e1-c2ab26a22ba2",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-10-01T19:27:08.693Z",
      "updatedAt": "2021-10-02T14:41:01.116Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1272556,
        "docId": "5a6e0fc5-675d-4fc2-b873-9eef2eb1fb37",
        "content": "## Структура бота начиная с корня\n1. index.js - файл инициализации самого бота, а так же подключения к БД и событий бота.\n2. assets - тут лежат различные вспомогательные ресурсы, к примеру это могут быть кнопки\n3. db - тут находится подключение к БД, модели, а так же сервисы\n4. events - тут создаются события",
        "message": "",
        "created": "2021-10-02T14:41:01.106Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "d8e37e12-080f-43a6-81a6-36e9e2bda7e1",
      "emoji": null,
      "title": "Первые шаги",
      "content": "",
      "headId": 1249496,
      "archivedAt": null,
      "folderPathname": "/TelegramBot/Гайд по созданию",
      "parentFolderId": "1f174df0-ae1f-4017-b4e1-c2ab26a22ba2",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-28T16:30:10.536Z",
      "updatedAt": "2021-09-28T16:36:46.248Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1249496,
        "docId": "d8e37e12-080f-43a6-81a6-36e9e2bda7e1",
        "content": "1. Открываем телеграм и ищем канал __botfather__\n2. Нажимаем __START__\n3. Выбираем (или вводим) команду __/newbot__\n4. После вводим имя бота, тут можно ввести абсолютно любое название оно будет отображаться пользователям\n5. После вводим имя по которому можно будет найти бота в поиске, самое главное что бы имя заканчивалось на __Bot__\n6. После мы получаем сообщение с ссылкой и токеном бота. ",
        "message": "",
        "created": "2021-09-28T16:36:46.238Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "e1fceddb-b50b-4116-90b5-23e88ba0af7e",
      "emoji": null,
      "title": "Настройщик",
      "content": "",
      "headId": null,
      "archivedAt": null,
      "folderPathname": "/TelegramBot",
      "parentFolderId": "8de55853-9cca-4b79-a471-eba49be242f5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-28T08:39:44.670Z",
      "updatedAt": "2021-09-28T08:39:44.670Z",
      "version": 1,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": null
    },
    {
      "id": "87b2a7b4-124a-4a05-8875-0ae65904da4e",
      "emoji": null,
      "title": "Мессенждер",
      "content": "",
      "headId": 1246677,
      "archivedAt": null,
      "folderPathname": "/TelegramBot",
      "parentFolderId": "8de55853-9cca-4b79-a471-eba49be242f5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-28T08:39:33.014Z",
      "updatedAt": "2021-09-28T09:12:10.745Z",
      "version": 5,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1246677,
        "docId": "87b2a7b4-124a-4a05-8875-0ae65904da4e",
        "content": "Я буду записывать боту задачу а он будет мне о них напоминать, единственное надо что бы было несколько режимов задач.\n\n## Режимы: \n\n  1. Классическая запись и напоминание. То есть я просто вызываю бота и пишу название задачи и время в которое мне надо ней напомнить. Но тут надо проработать сценарий приоритетов который будет обуславливать то через какой промежуток бот будет мне снова напоминать об этой задаче.  ",
        "message": "",
        "created": "2021-09-28T09:12:10.731Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "b059c776-34f5-42d4-b45d-e5af14856a50",
      "emoji": null,
      "title": "Какой он должен быть",
      "content": "",
      "headId": 1246456,
      "archivedAt": null,
      "folderPathname": "/TelegramBot",
      "parentFolderId": "8de55853-9cca-4b79-a471-eba49be242f5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-28T05:35:56.011Z",
      "updatedAt": "2021-09-28T08:39:28.398Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1246456,
        "docId": "b059c776-34f5-42d4-b45d-e5af14856a50",
        "content": "Тут важный вопрос какую тематику ему задать \n1. Фэнтезийную типо помощник ученика мага.\n2. Или же футуристическую что то Вроде ИИ на борту корабля Шепарда.\n\nИ какие мои насущные задачи он будет решать?\n1. Мессенджер задач\n2. Помогать настраивать меня на нужный лад\n\n\n\n",
        "message": "",
        "created": "2021-09-28T08:39:28.390Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f06525de-66f7-4193-9f75-d7960e5dc950",
      "emoji": null,
      "title": "Начало",
      "content": "",
      "headId": 1409118,
      "archivedAt": null,
      "folderPathname": "/MyNote",
      "parentFolderId": "78d8fe07-cb7d-4dd6-8d80-885bf60dd0b6",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-28T05:24:25.351Z",
      "updatedAt": "2021-10-26T16:24:48.733Z",
      "version": 11,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1409118,
        "docId": "f06525de-66f7-4193-9f75-d7960e5dc950",
        "content": "Нашел видео по созданию md редактора [https://www.youtube.com/watch?v=mWg6NWaxEOs&ab_channel=ThapaTechnical](url)\nBackend - NestJS\nFrontend - NextJS\nDataBase - Postgres возможно монго, определюсь после урока\nLink backe and front - GraphQL\nИ это все на TS\n\nВ виду того что самое главное начать и мне нужен по скорее стабильный обработчик заметок, я решил начать создание MyNote как можно быстрее. \n\nМне осталось посмотреть видео от UlbiTV\n\nПосле надо изучить как GraphQL работает с NestJS\n\nИ после будет полезно изучить как устроен сервер на RetterDev\n\nДальше можно начинать создавать проект\nПервая что я создам это обычный редактор md\nИ файловый менеджер слева с возможностью создавать файлы и папки\n",
        "message": "",
        "created": "2021-10-26T16:24:48.724Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "42dad1c7-3f37-47a0-9951-68e2860dbe9d",
      "emoji": null,
      "title": "Наследование",
      "content": "",
      "headId": 1240887,
      "archivedAt": null,
      "folderPathname": "/JS/ООП",
      "parentFolderId": "065d4d1f-9664-413a-838d-abbecd774cdb",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-27T13:30:57.044Z",
      "updatedAt": "2021-09-27T14:13:29.895Z",
      "version": 8,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1240887,
        "docId": "42dad1c7-3f37-47a0-9951-68e2860dbe9d",
        "content": "Эта концепция позволяет наследовать свойства одними классами от других.\n\nДля примера создадим класс человека\n``` js\nclass Person {\n  private _firstName;\n  private _lastName;\n  private _age;\n  \n  constructor(firstName, lastName, age) {\n    this._firstName = firstName;\n    this._lastName = lastName;\n    this._age = age;\n  }\n  \n  \n  get firstName () {\n    return  this._firstName;\n  }\n  get lastName () {\n    return  this._lastName;\n  }\n  get age () {\n    return  this._age;\n  }\n  \n  set firstName (value) {\n    this._firstName = value;\n  }\n  set lastName (value) {\n    this._lastName = value;\n  }\n  set age (value) {\n    this._age = value;\n  }\n}\n```\n\nИ теперь мы создадим следующий класс который унаследует вышесозданый\n\n``` js\n// extends позволят нам указать тот класс от \n// которого мы наследуемся\nclass Employee extends Person {\n  private inn;\n  private number;\n  private snils;\n  \n  // В конструкторе указываем и в том чисел и свойства родительского класса которые необходимо инициализировать на старте\n  constructor(firstName, lastName, age, inn, number, snils) {\n    // super инициализирует сначала свойства \n    // родителя а затем и дочернего класса\n    super(firstName, lastName, age)\n    this.inn = inn\n    this.number = number\n    this.snils = snils\n  }\n}\n```\n\nИ так можно до бескнечности и затем создаем объект от класса указывая все свойства которые надо инициализировать на старте (в том числе родительские)\n\n``` js\nconst employeer = new Employee('Ulbi', 'TV', 15, 15, 15, 15)\n```",
        "message": "",
        "created": "2021-09-27T14:13:29.872Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "cf63a670-9b98-40be-a7f6-10d2f4cc97f4",
      "emoji": null,
      "title": "Инкапсуляция и сокрытие",
      "content": "",
      "headId": 1240367,
      "archivedAt": null,
      "folderPathname": "/JS/ООП",
      "parentFolderId": "065d4d1f-9664-413a-838d-abbecd774cdb",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-27T12:14:12.223Z",
      "updatedAt": "2021-09-27T12:47:39.418Z",
      "version": 11,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1240367,
        "docId": "cf63a670-9b98-40be-a7f6-10d2f4cc97f4",
        "content": "# Инкапсуляция\nЕсли процедурный код это один сплошной поток выполнения кода, то такой аспект ООП как инкапсуляция подразумевает взаимодействие отдельных как я называю капсулированных участков кода со своими методами и свойствами.\n\n# Сокрытие \nКак понятно из название это скрытие определенных свойств и методов класса доступных только внутри него. Что бы их случайно (или не совсем)) не изменили и все это дело не поломалось.\n\nК примеру прежде чем создать такое скрытое свойство мы помечаем его как __private__\n\n```js\nclass Rectangle {\n  // Как понятно из описания выше я сделал \n  // свойства ниже приватными и теперь доступ к \n  // ним можно получить исключительно внутри \n  // класса\n  private _height;\n  private _width;\n  // Их можно спокойно задавать в конструкторе \n  // при создании объекта из класса\n  constructor(w, h){\n    this._height = h;\n    this._width = w;\n  }\n  // Хорошей практикой считается все свойства \n  // делать приватными. И делать их доступными \n  // для чтения посредством гетеров и доступными \n  // для редактирования через сетеры как показано \n  // ниже  \n  get height() {\n    return this._height\n  }\n  \n  set height(value) {\n    if (value <= 0) {\n      this.height = 1\n    } else {\n      this.height = value\n    }\n  }\n  // Пример показывающий что внутри класса \n  // приватные свойства используются в точь точь \n  // как и публичные\n  calcArea () {\n    retutn this._height * this._width\n  }\n  \n  calcPerimeter () {\n    return (this._height + this._width) * 2\n  }\n}\n\nconst rect = new Rectangle(5, 10)\n\n// Вот так вот просто посредством сеттеров \n// задается значение приватному свойству\nrect.height = -2\n// А вот пример вывод этого свойства посредством \n// геттера\nconsole.log(rect.height)\n```\n\nАбсолютно таким же макаром создаются и методы и вызываться в классе через __this__",
        "message": "",
        "created": "2021-09-27T12:47:39.408Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "b4f0426d-2709-4083-8424-22850fa69502",
      "emoji": null,
      "title": "Generic pro",
      "content": "",
      "headId": 1197115,
      "archivedAt": null,
      "folderPathname": "/React/TS/Продвинутый TS",
      "parentFolderId": "0b8e61e2-bc62-4657-94e4-73ce0212bbbb",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-19T08:16:36.696Z",
      "updatedAt": "2021-09-19T08:25:19.534Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1197115,
        "docId": "b4f0426d-2709-4083-8424-22850fa69502",
        "content": "1. Тут мы задаем прием дженерик типов которые затем принимаеются в аргуементы\nТо есть как я понял мы говорим TS что здесь мы будем работатьс некими\nтипами T и R, так же мы говорим что эти типы наследуються от\nобъектов, тоесть являються типом объекта\nНачинаю подозревать что так и рекомендуется работать с задаванием типовфункци\n\nИ еще как я понял дженерики объявляються перед функциями\n\n```ts\nconst mergeObjects = <T extends object, R extends object>(a: T, b: R): T & R => {\n    return Object.assign({}, a, b)\n}\n\nconst merged = mergeObjects({name: 'Vladilen'}, {age: 26})\n```\n\n2. Тут идет демонстрация того что дженерик типы могут наследоваться от\n не только заготовленных типов но пользовательских интерфейсов\nввиду чего полностью преобретать их типизацию (помимо своей уже заданной)\n\n``` ts\ninterface ILength {\n    length: number\n}\n\nconst withCount = <T extends ILength>(value: T): {value: T, count: string} => {\n    return {\n        value,\n        count: `In this field ${value.length} symbols`\n    }\n}\n```\n\n3. Тут демонстрируется пример работы с объектами, где мы можем указывать\nчто мы работаем с ключами того или иного объекта\n\n```ts\nconst getObjectValue = <T extends object, R extends keyof T>(obj: T, key: R) => {\n    return obj[key]\n}\n\nconst person = {\n    name: 'Vladilen',\n    age: 26,\n    job: 'JavaScript'\n}\n```\n\n4. Тут показан пример множественного наследования дженериком\n\n``` ts\nclass Collection <T extends number | string | boolean>{\n    // private _items: T[] = []\n\n    constructor(private _items: T[] = []) {\n    }\n\n    add(item: T) {\n        this._items.push(item)\n    }\n\n    remove(item: T) {\n        this._items = this._items.filter(i => i !== item)\n    }\n\n    get items (): T[] {\n        return this._items\n    }\n}\n```\n\n5. Тут мы используем 2 свойства дженериков\n    \n   a. Partial помогает нам объяснить TS что этот объект наследутся\nот определенного интерфейса но в нем может пока не хватать свойсв\n\n    \n  b. Readonly объясняет что массив или объект только для чтения\n  \n``` ts\ninterface Car {\n    model: string\n    year: number\n}\n\nconst createAndValidateCar = (model: string, year: number): Car => {\n    const car: Partial<Car> = {}\n\n    if (model.length > 3){\n        car.model = model\n    }\n    if (year > 2000){\n        car.year = year\n    }\n\n    return car as Car\n}\n\n///\n\nconst cars: Readonly<Array<string>> = ['Ford', 'Audi']\n// cars.shift()\n// cars[1]\n\nconst ford: Readonly<Car> = {\n    model: 'Ford',\n    year: 2000\n}\n```",
        "message": "",
        "created": "2021-09-19T08:25:19.525Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "3e07613f-f3fd-401e-98f0-ad3adbea6a4f",
      "emoji": null,
      "title": "tsconfig.json",
      "content": "",
      "headId": 1196899,
      "archivedAt": null,
      "folderPathname": "/React/TS/Продвинутый TS",
      "parentFolderId": "0b8e61e2-bc62-4657-94e4-73ce0212bbbb",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-19T06:46:18.482Z",
      "updatedAt": "2021-09-19T08:16:25.507Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1196899,
        "docId": "3e07613f-f3fd-401e-98f0-ad3adbea6a4f",
        "content": "# Основные параметры\n``` json\n  /* Указываем корневую папку файлов с которыми мы работаем */\n\"rootDir\": \"./src\",\n\n  /* Позволяеет генерировать map фалйы необходимы для отображения ts в браузере. */\n\"sourceMap\": true, \n\n/* Указываем куда компилировать ts файлы. */\n\"outDir\": \"./dist\"\n\n/* Удаляет коментарии в финальном билде. */\n \"removeComments\": true, \n\n//  Cюда указываются пути которые следует исключить из компиляции ts\n//  \"exclude\": [\"./module.ts\"]\n//  Cюда указываются пути которые следует добавить компиляции ts\n//  \"include\": [\"./src/**/*\"]\n//   Cюда указываются файлы следует добавить компиляции ts\n//   \"files\": [\"./module.ts\"]\n```",
        "message": "",
        "created": "2021-09-19T06:50:16.361Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "41deb9a7-e963-4775-b89c-0db019afbd22",
      "emoji": null,
      "title": "Разбивание компонента формы",
      "content": "",
      "headId": 1194806,
      "archivedAt": null,
      "folderPathname": "/React/Formik + Apollo",
      "parentFolderId": "0f82db6f-9cac-4d03-aa81-e65c7778908d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-18T12:38:59.697Z",
      "updatedAt": "2021-09-18T12:45:37.887Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1194806,
        "docId": "41deb9a7-e963-4775-b89c-0db019afbd22",
        "content": "Необязательно создавать один большой компонент формы, formik довольно спокойно позволяет распределять свой функционал между компоннетами ниже.\n\nК прмимеру вот мы инициализировали formik в родительском компоненте\n\n``` js\n  const formik = useFormik({\n    initialValues,\n    validationSchema: editUserSchema,\n    onSubmit: (values) => {updateUser({variables: values})},\n  })\n```\n\nМы можем спокойно передать формик в дочерние компоненты\n\n``` js\n<EditUserForm formik={formik} loading={loading} resetNotifications={resetNotifications}/>\n```\n\nИ так же как и вседа использвать его в этом дочернем компоненте и даже передавать его дальше\n\n```js\n\n    <form noValidate onSubmit={formik.handleSubmit}>\n      <EditUserMain formik={formik}/>\n      <EditUserPlan formik={formik}/>\n      <EditUserChangePassword formik={formik} loading={loading} resetNotifications={resetNotifications}/>\n    </form>\n```\n\n``` js\n   <input\n              type='text'\n              {...formik.getFieldProps('name')}\n              className={clsx(\n                'dev-input',\n                {\n                  'border border-danger': formik.touched.name && formik.errors.name,\n                },\n                {\n                  'border border-success': formik.touched.name && !formik.errors.name,\n                }\n              )}\n              placeholder='Name'\n            />\n            {formik.touched.name && formik.errors.name && (\n              <div className='fv-plugins-message-container text-danger'>\n                <div className='fv-help-block'>\n                  <span role='alert'>{formik.errors.name}</span>\n                </div>\n              </div>\n            )}\n```",
        "message": "",
        "created": "2021-09-18T12:45:37.878Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "bec76bfb-95a0-45d9-bac2-4219aedfef17",
      "emoji": null,
      "title": "Получение и установка данных в значения полей",
      "content": "",
      "headId": 1194793,
      "archivedAt": null,
      "folderPathname": "/React/Formik + Apollo",
      "parentFolderId": "0f82db6f-9cac-4d03-aa81-e65c7778908d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-18T12:34:16.664Z",
      "updatedAt": "2021-09-18T12:37:05.176Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1194793,
        "docId": "bec76bfb-95a0-45d9-bac2-4219aedfef17",
        "content": "Если нам надо что бы допустим в полях изменения пользователя выводились его изначальные данные (которые допустим мы не можем получить сходу). То можно установить их способом показанным в примере ниже\n\n``` js\nuseEffect(() => {\n    if(data){\n      formik.setValues({\n        password: '',\n        plan_trial_done: data.getUserById.plan_trial_done,\n        plan_id: data.getUserById.plan.id,\n        is_admin: data.getUserById.is_admin ? '1' : '0',\n        active: data.getUserById.active,\n        email: data.getUserById.email,\n        name: data.getUserById.name,\n        changepassword: '',\n        plan_expiration_date: data.getUserById.plan_expiration_date\n      });\n    }\n  }, [data])\n```\n\nИ в итоге эти данные будут отображаться в инпутах ",
        "message": "",
        "created": "2021-09-18T12:37:05.167Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "87eb057e-799f-46f7-be51-ba68f2e29c1e",
      "emoji": null,
      "title": "Обработка данных перед отправкой",
      "content": "",
      "headId": 1194785,
      "archivedAt": null,
      "folderPathname": "/React/Formik + Apollo",
      "parentFolderId": "0f82db6f-9cac-4d03-aa81-e65c7778908d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-18T12:30:13.435Z",
      "updatedAt": "2021-09-18T12:34:06.328Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1194785,
        "docId": "87eb057e-799f-46f7-be51-ba68f2e29c1e",
        "content": "В промежутке между нажатием кнопки отправить и срабатыванием мутации данные можно обработать. В примере ниже видно как перед отправкой идет получение даты из кеша для ее совмещения с другими данными для отправки. Так же интересно как добавляются другие данные в мутацию перед отправкой \n\n``` js\nonSubmit: (values) => {\n\n      const date = client.readQuery({\n        query: READ_DATE,\n      });\n\n      updateUser({variables: {\n        ...values,\n          id: id,\n          is_admin: !!+values.is_admin,\n          active: +values.active,\n          plan_id: +values.plan_id,\n          plan_trial_done: +values.plan_trial_done,\n          plan_expiration_date: date.date.date\n      }})\n    },\n  })\n```",
        "message": "",
        "created": "2021-09-18T12:34:06.320Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "dfd6b686-4436-4c2e-b375-45f6d90cf7fe",
      "emoji": null,
      "title": "Базовый пример на регистрации",
      "content": "",
      "headId": 1194730,
      "archivedAt": null,
      "folderPathname": "/React/Formik + Apollo",
      "parentFolderId": "0f82db6f-9cac-4d03-aa81-e65c7778908d",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-18T12:03:53.004Z",
      "updatedAt": "2021-09-18T12:19:01.763Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1194730,
        "docId": "dfd6b686-4436-4c2e-b375-45f6d90cf7fe",
        "content": "## initialValues \nЭто начальные значения для формы которые необходимо указать. И жедательно над компонентом \n\n``` js\nconst initialValues = {\n  firstname: '',\n  email: '',\n  password: '',\n  changepassword: '',\n}\n```\n\n## validationScheam \nЭто схема валидации, в них указывается обязательные параметры валидности значения\n\n```js\nconst registrationSchema = Yup.object().shape({\n  firstname: Yup.string()\n    .min(3, 'Minimum 3 symbols')\n    .max(50, 'Maximum 50 symbols')\n    .required('First name is required'),\n  email: Yup.string()\n    .email('Wrong email format')\n    .min(3, 'Minimum 3 symbols')\n    .max(50, 'Maximum 50 symbols')\n    .required('Email is required'),\n  password: Yup.string()\n    .min(3, 'Minimum 3 symbols')\n    .max(50, 'Maximum 50 symbols')\n    .required('Password is required'),\n  changepassword: Yup.string()\n    .required('Password confirmation is required')\n    .when('password', {\n      is: (val: string) => (!!(val && val.length > 0)),\n      then: Yup.string().oneOf([Yup.ref('password')], \"Password and Confirm Password didn't match\"),\n    }),\n})\n```\n\n## Инициализируем мутацию\n``` js\n  const [createUser, { loading }] = useCreateUser();\n```\n\n## Инициализируем формик\n\n``` js\n const formik = useFormik({\n   // Указываем начальное знгачение\n    initialValues,\n   // Указываем схему валидации\n    validationSchema: registrationSchema,\n   // Указываем что происходит при отправки формы\n   // values = значения собранные с формы\n    onSubmit: (values) => {\n      // ОТправляем мутацию передав в нее значения формы\n      createUser({variables: values})\n      // Ну а тут посредством промисов указываеми дальнейшие действия\n        .then((data) => history.push('/dashboard'))\n        .catch((err) => console.log(err))\n    },\n  })\n```\n\n## Теперь разберем саму структуру формы\n\n```js\n<form\n  className='form'\n  // Отключаем стандартную валидацию\n  noValidate\n  // Указываем что при отправке должен сработать обработчик отправки формика\n  onSubmit={formik.handleSubmit}\n    >\n          <input\n            placeholder='Name'\n            type='text'\n            // Обязательно для формика следут указать имя поля \n            {...formik.getFieldProps('name')}\n            className={clsx(\n              'form-control form-control-lg form-control-solid',\n               // Обработчик ошибок \n              {\n                'is-invalid': formik.touched.name && formik.errors.name,\n              },\n              {\n                'is-valid': formik.touched.name && !formik.errors.name,\n              }\n            )}\n          />\n          // БЛок с выводом предупреждений о неккоректном вводе\n          {formik.touched.name && formik.errors.name && (\n            <div className='fv-plugins-message-container'>\n              <div className='fv-help-block'>\n                <span role='alert'>{formik.errors.name}</span>\n              </div>\n            </div>\n          )}\n\n\n <button\n    type='submit'\n    id='kt_sign_up_submit'\n    className='btn btn-lg btn-primary w-100 mb-5'\n    // Разрешаем кнопке срабатывать только когда все поля валидные\n    disabled={!formik.isValid }\n  >\n  </button>\n</form>\n```",
        "message": "",
        "created": "2021-09-18T12:19:01.714Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "416f5783-525b-45db-b204-8602fc2f574d",
      "emoji": null,
      "title": "Главный компонент",
      "content": "",
      "headId": 1194676,
      "archivedAt": null,
      "folderPathname": "/Tracking/Компоненты/Работа с формиком на примере формы измения данных пользователя",
      "parentFolderId": "57f77c6f-d390-4104-a6a4-7fed8ccaf3a7",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-18T11:59:33.595Z",
      "updatedAt": "2021-09-18T12:00:17.622Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1194676,
        "docId": "416f5783-525b-45db-b204-8602fc2f574d",
        "content": "``` js\nconst EditUserContent = () => {\n  const [success, setSuccess] = useState(false)\n  const [fail, setFail] = useState(false)\n  const [msg, setMessage] = useState('')\n  const client = useApolloClient()\n  const id = useGetIdFromUrl()\n\n  const [getUser, {data}] = useLazyQuery(GET_USER, {\n    variables: {\n      id:  id\n    }\n  })\n\n  const [updateUser, { loading, error}] = useUpdateUser()\n\n  const formik = useFormik({\n    initialValues,\n    validationSchema: editUserSchema,\n    onSubmit: (values) => {\n\n      const date = client.readQuery({\n        query: READ_DATE,\n      });\n\n      updateUser({variables: {\n        ...values,\n          id: id,\n          is_admin: !!+values.is_admin,\n          active: +values.active,\n          plan_id: +values.plan_id,\n          plan_trial_done: +values.plan_trial_done,\n          plan_expiration_date: date.date.date\n      }})\n        .then(() => {\n          window.scrollTo(0, 0)\n          getUser()\n          setSuccess(true)\n        })\n        .catch(err => setFail(true))\n    },\n  })\n\n  useEffect(() => {getUser()}, [])\n\n  useEffect(() => {\n    if(data){\n      if(!!localStorage.getItem('new-user')){\n        localStorage.removeItem('new-user')\n        setSuccess(true)\n        setMessage('User created successfully')\n      }\n\n      formik.setValues({\n        password: '',\n        plan_trial_done: data.getUserById.plan_trial_done,\n        plan_id: data.getUserById.plan.id,\n        is_admin: data.getUserById.is_admin ? '1' : '0',\n        active: data.getUserById.active,\n        email: data.getUserById.email,\n        name: data.getUserById.name,\n        changepassword: '',\n        plan_expiration_date: data.getUserById.plan_expiration_date\n      });\n    }\n  }, [data])\n\n  const resetNotifications = () => {\n    setSuccess(false)\n    setFail(false)\n  }\n\n\n  return (\n    <div>\n     <EditUserNotifications setSuccess={setSuccess}  setFail={setFail}  success={success} fail={fail} error={error && error.message} msg={msg} setMessage={setMessage}/>\n      <div className=\"w-100 p-5 rounded-1 dev-view-user-main\">\n        <EditUserForm formik={formik} loading={loading} resetNotifications={resetNotifications}/>\n      </div>\n    </div>\n  );\n};\n\nexport default EditUserContent;\n```",
        "message": "",
        "created": "2021-09-18T12:00:17.613Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "8e2f8195-91a2-45db-8c8c-fad78fd84d8e",
      "emoji": null,
      "title": "Составление мутаций",
      "content": "",
      "headId": 1194592,
      "archivedAt": null,
      "folderPathname": "/React/Apollo",
      "parentFolderId": "917eb315-1d9e-4a59-8923-1813b06e6ef5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-18T11:27:58.105Z",
      "updatedAt": "2021-09-18T11:35:56.795Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1194592,
        "docId": "8e2f8195-91a2-45db-8c8c-fad78fd84d8e",
        "content": "Составлять запросы к мутации достаточно просто\n\n``` js\nexport const DEACTIVATE_MANY_USERS = gql`\n    mutation DeactivateManyUsers(\n    // Указываем типы данных аргументов которые принимает мутация\n        $users_id: [Float!]!\n    ){\n    // Тут мы указываем эти самы аргументы\n        deactivateManyUsers(\n         users_id: $users_id\n        )\n        // А тут мы записываем данные которые хотим принять обратно (если конечно надо)\n        {\n            id\n            email\n            name\n        }\n    }\n`\n```\n\nИ после пихаем это дело в хук\n\n``` js\nexport const useDeactivateManyUsers = () => useMutation(DEACTIVATE_MANY_USERS)\n```\n\nИ применяем его в компоненте таким вот образом\n\n``` js\n// Первое имя это название функции которая будет выполнять мутацию\nconst [doDeactivate, (data, loading, error)] = useDeactivateManyUsers()\n```\n\nДалее стоит запустить метод выполенния мутации \n\n``` js\ndoDeactivate({\n        variables: {users_id: arrId}\n      })\n```",
        "message": "",
        "created": "2021-09-18T11:35:56.771Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "0d130439-6f15-4c69-80eb-13a19588e7de",
      "emoji": null,
      "title": "Вложенная деструктуризация объектов",
      "content": "",
      "headId": 1194565,
      "archivedAt": null,
      "folderPathname": "/JS",
      "parentFolderId": "18764da7-5e98-4f6f-adf6-14055a45e2c9",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-18T11:25:52.560Z",
      "updatedAt": "2021-09-18T11:27:20.098Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1194565,
        "docId": "0d130439-6f15-4c69-80eb-13a19588e7de",
        "content": "``` js\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: [\"Cake\", \"Donut\"],\n  extra: true\n};\n\n// деструктуризация разбита на несколько строк для ясности\nlet {\n  size: { // положим size сюда\n    width,\n    height\n  },\n  items: [item1, item2], // добавим элементы к items\n  title = \"Menu\" // отсутствует в объекте (используется значение по умолчанию)\n} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // Cake\nalert(item2);  // Donut\n```\n\nПо сути мы просто повторяем структуру объекта и в итоге можем использовать его свойства как имена обычных переменных",
        "message": "",
        "created": "2021-09-18T11:27:20.077Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "f1f27022-41af-4d2b-88ed-563c0428f7ff",
      "emoji": null,
      "title": "Создание модальных окон",
      "content": "",
      "headId": 1194389,
      "archivedAt": null,
      "folderPathname": "/Заметки",
      "parentFolderId": "f3ab0b81-040b-4fed-ad71-761253447dad",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-18T10:08:09.540Z",
      "updatedAt": "2021-09-18T10:17:03.333Z",
      "version": 3,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "309011fd-0b61-4b75-a6fe-a3a711e8a079",
      "head": {
        "id": 1194389,
        "docId": "f1f27022-41af-4d2b-88ed-563c0428f7ff",
        "content": "## Для того что бы создать модальное окно следует: \n1. Добавить кнопек вызова следующие атрибуты:\n\n``` js\n// Тут мы обозначем что эта кнопка будет вызывать модальное окно\n  data-bs-toggle=\"modal\"\n// А тут мы указываем id модалки которую мы вызываем этой кнопкой\n  data-bs-target=\"#kt_modal_2\"\n```\n2. Создаем компонента модалки:\n\n``` js\nconst ExampleModal = () => {\n\n  return (\n// Тут мы указываем id по которому будем вызывать модальное окно (для \n// последующих модалок желательно менять только цифру)\n    <div className=\"modal fade\" tabIndex={-1} id=\"kt_modal_2\">\n      <div className=\"modal-dialog\">\n        <div className=\"modal-content\">\n          <div className=\"modal-header border-0\">\n            <h5 className=\"modal-title d-flex align-items-center fs-2\">\n// Тут у нас заголовок\n            </h5>\n            <div\n              className=\"btn-sm ms-2\"\n              data-bs-dismiss=\"modal\"\n              aria-label=\"Close\"\n            >\n// Иконка крестика закрытия...\n            </div>\n          </div>\n// Контент...\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ExampleModal;\n```\n\n3. Выносим модалку в MasterLayout\n\n``` js\nconst MasterLayout: React.FC = ({children}) => {\n  return (\n    <PageDataProvider>\n      <div className='page d-flex flex-row flex-column-fluid'>\n        <AsideDefault />\n        <div className='wrapper d-flex flex-column flex-row-fluid' id='kt_wrapper'>\n            <HeaderWrapper />\n\n            <div id='kt_content' className='content d-flex flex-column flex-column-fluid '>\n              {/*<Toolbar />*/}\n                <div className='post d-flex flex-column-fluid ' id='kt_post'>\n                    <Content>{children}</Content>\n                </div>\n            </div>\n            <Footer />\n        </div>\n    </div>\n\n      {/* begin:: Drawers */}\n      <ActivityDrawer />\n      {/*<ExploreMain />*/}\n      <DrawerMessenger />\n      {/* end:: Drawers */}\n\n      {/* begin:: Modals */}\n      <Main />\n      <InviteUsers />\n// Вот сюдой\n      <ExampleModal/>\n      {/* end:: Modals */}\n\n      <MasterInit />\n      <ScrollTop />\n    </PageDataProvider>\n  )\n}\n```",
        "message": "",
        "created": "2021-09-18T10:17:03.323Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "43fc6f1c-656c-4360-8de0-9a9c7d82d131",
      "emoji": null,
      "title": "Работа с массивами и пример записи и перезаписи",
      "content": "",
      "headId": 1194556,
      "archivedAt": null,
      "folderPathname": "/React/Apollo/ApolloCache",
      "parentFolderId": "869a9191-ec26-460b-b074-c591d9a6cc8e",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-16T14:32:45.968Z",
      "updatedAt": "2021-09-18T11:23:05.306Z",
      "version": 7,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1194556,
        "docId": "43fc6f1c-656c-4360-8de0-9a9c7d82d131",
        "content": "\n### Создаем массив (тут это будет к примеру массив задач)\n\n``` js\n  client.writeQuery({\n    query: gql`\n    query WriteTodo{\n      todos {\n        id\n        text\n        completed\n      }\n    }`,\n    data: { // Contains the data to write\n      todos: [{\n        __typename: 'Todo',\n        id: 5,\n        text: 'Buy grapes 🍇',\n        completed: false\n        }\n      ],\n    },\n  });\n```\n\n### Далее допустим на надо добавить еще одну задачу для этого\n1. Создаем запрос на получение предыдущих записей\n\n``` js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n```\n2. Получаем предыдущие записи\n\n``` js\n  const data = client.readQuery({ query });\n```\n\n3. Создаем объект со следующей записей\n\n``` js\n  const myNewTodo = {\n    id: '6',\n    text: 'Start using Apollo Client.',\n    completed: false,\n    __typename: 'Todo',\n  };\n```\n\n4. И после перезаписываем массив с задачами добавляя новую задачу\n\n``` js\nif(data){\n    // Напишите обратно в список дел, добавив новый элемент\n    client.writeQuery({\n      query,\n      data: {\n        todos: [...data.todos, myNewTodo],\n      },\n    });\n  }\n```\n\n### И теперь посомтри наши все записи\n1. Составляем запрос\n  ``` js\n  const READ_TODO = gql`\n    query ReadTodo{\n      todos{\n        id\n        text\n        completed\n      }\n    }\n  `;\n  ```\n  \n2. Делаем запрос\n\n  ```js\n    const todo = client.readQuery({\n    query: READ_TODO,\n    variables: { // Provide any required variables here\n      id: 5,\n    },\n  });\n  ```\n  \n  ### Если мы хотим очистить наш массив\n  Просто перезаписываем то место на пустой массив\n  ``` js\n     client.writeQuery({\n        query,\n        data: {\n          todos: [],\n        },\n      });\n  ```",
        "message": "",
        "created": "2021-09-18T11:23:05.286Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "350f7340-23a1-4009-a5e9-8ed811a50271",
      "emoji": null,
      "title": "writeFragment&readFragment",
      "content": "",
      "headId": 1185090,
      "archivedAt": null,
      "folderPathname": "/React/Apollo/ApolloCache",
      "parentFolderId": "869a9191-ec26-460b-b074-c591d9a6cc8e",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-16T14:26:07.441Z",
      "updatedAt": "2021-09-16T14:42:53.417Z",
      "version": 4,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1185090,
        "docId": "350f7340-23a1-4009-a5e9-8ed811a50271",
        "content": "## Пример записи данных\n\nОдин ньюанс, эти инструменты пригодны только в том случае если в кеше уже есть запись запись занесенная туда с помощью writeQuery.\n\n``` js\n// Запрос к кешу\nclient.writeFragment({\n  // индефикаторы состоящие из типа и ид (которые мы само собой создали с \n  // writeQuery)\n  id: 'Todo:5',\n  // сам запрос\n  fragment: gql`\n    fragment MyTodo on Todo {\n      completed\n      text\n    }\n  `,\n  // Данные которые записываем\n  data: {\n    text: 'Text'\n    completed: true,\n  },\n});\n```\n\n## Присер чтения данных\n``` js\nconst todo = client.readFragment({\n  // Индентификаторы по которым ищем запись (которые мы само собой создали с \n  // writeQuery)\n  id: 'Todo:5', // The value of the to-do item's cache ID\n  // Запрос с данными которые хотим достать\n  fragment: gql`\n    fragment MyTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n",
        "message": "",
        "created": "2021-09-16T14:42:53.408Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "2f04205e-c6b7-4ae0-a44d-93d1a0e8e93d",
      "emoji": null,
      "title": "writeQuery&readQuery",
      "content": "",
      "headId": 1184910,
      "archivedAt": null,
      "folderPathname": "/React/Apollo/ApolloCache",
      "parentFolderId": "869a9191-ec26-460b-b074-c591d9a6cc8e",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-16T13:54:29.294Z",
      "updatedAt": "2021-09-16T14:25:41.216Z",
      "version": 6,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1184910,
        "docId": "2f04205e-c6b7-4ae0-a44d-93d1a0e8e93d",
        "content": "\n\nПример записи данных\n``` js\n  client.writeQuery({\n    query: gql`\n    // Если планируеться записывать несколько значений и затем искать их \n    // по уникальным значениям то указываем в запрос прием параметров\n    query WriteTodo($id: Int!) {\n    // Название объекта под которым будет храниться сущность так же тут \n    // указываем переменную по которой будем искать это дело в случае запроса \n    //к кешу\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }`,\n    data: { // Contains the data to write\n      // Название сущности\n      todo: {\n        // Тип сущности\n        __typename: 'Todo',\n        // индефикатор по которому в этом запросе у нас и будет происходить \n        // поиск\n        id: 5,\n        // и остальная контентная часть\n        text: 'Buy grapes 🍇',\n        completed: false\n      },\n    },\n    // если при чтении этих данных с кеша подразумевается поиск по каким либо \n    // параметрам то указываем эти параметры тут (если нет то не указываем)\n    variables: {\n      id: 5\n    }\n  });\n```\n\nПример чтения данных \n``` js\n// Как и с обычными запросами сначала конструируем их\nconst READ_TODO = gql`\n// Не забываем за параметры\n  query ReadTodo($id: ID!) {\n  // а так же указываем название сущности\n    todo(id: $id) {\n      id\n      text\n      completed\n    }\n  }\n`;\n\n// Fetch the cached to-do item with ID 5\n// Тут инициируем запрос \nconst { todo } = client.readQuery({\n  // Передаем его\n  query: READ_TODO,\n  // и указываем переменную для поиска\n  variables: { // Provide any required variables here\n    id: 5,\n  },\n});\n```\n\n### Редактирование существующих данных\n\nВ приведенном выше примере, если ваш кеш уже содержит Todoобъект с идентификатором 5, writeQuery перезаписывает поля, которые включены в data(другие поля сохраняются). Кароче делаем тайкой же запрос только с другими данными и Apollo будет перезаписывать все это дело.",
        "message": "",
        "created": "2021-09-16T14:07:24.930Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "8f48cad3-0d1d-45b5-9ef2-5f0d77c55c77",
      "emoji": null,
      "title": "Promise",
      "content": "",
      "headId": 1119278,
      "archivedAt": null,
      "folderPathname": "/JS",
      "parentFolderId": "18764da7-5e98-4f6f-adf6-14055a45e2c9",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-04T12:02:26.990Z",
      "updatedAt": "2021-09-04T12:59:55.631Z",
      "version": 8,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1119278,
        "docId": "8f48cad3-0d1d-45b5-9ef2-5f0d77c55c77",
        "content": "С помощью промисов я могу строить сценарии выполнения кода. То есть если говорить на человекопонятном языке я могу выстроить такую цепочку: \"После того как выполнится вот это необходимо вополнить вот то и да если вылетит ошибка сделай то то. Как всегда понятнее выйдет объяснить на коде.\n\n# Пример создания промисов\n\n``` js\n// Вот таким макаром можно создаеться промис.\n// То есть идет иникиализация класса.\n// Который принимает в себя callback \n// который в качестве аргументов принимает в себя две callback функции\n\n// 1. resolve - эта функция срабатывает в случае успеха \n// и аргументов в себя принимает то что надо вернуть\n// в случае этого самого успеха.\n\n// 2. reject - эта функция срабатывает в случае,\n// если в коде что то пойдет не так\n// и принимает она в себя то что надо вернуть в случае ошибки\nconst p = new Promise((resolve, reject) => {\n// Код который выполняется для примера\n  setTimeout(() => {\n    console.log('Preparing data...')\n    const backendData = {\n      server: 'aws',\n      port: 2000,\n      status: 'working'\n    }\n    // Вконце выполнения кода вызываю resolve и предпю ему то что надо \n    // вернуть в случае успеха\n    resolve(backendData)\n    // В случае ошибки вызываем reject() \n    reject(// тут передаем данные которые необходимо вернуть в случае ошибки)\n  }, 2000)\n})\n// Привычный then который принимает в себя  функцию,\n// которая принимает аргумент данные которые возвращает промис\n// в этой функции можно обрабатывать эти данные как угодно и\n// передавать и по цепочке then дальше\n\n// Так же здесь продемонстрирован того что функции могут и возвращать промис \n// и от их вызовов дальше можно выстраивать цепочки сценариев\np.then(data => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      data.modifed = true\n      resolve(data)\n    }, 2000)\n  })\n})\n.then(clientData => {\n  clientData.fromPromise = true\n  return clientData\n})\n// catch принимает в себя функцию которая принимает в себя \n// данные передаваемые в resolve и здесь пишется код\n// которые отрабатывается в случае ошибки\n.catch(err => console.error('Error: ', err))\n// finally принимает в себя функцию в которой выполняется код \n// необходимый для выполнения в любом случе (хоть в случае ошибки хоть успеха)\n.finally(() => console.log('Finally'))\n```\n\n# Пример создания функций которые возарщают промис\n```js \n// Здесь показан пример создания функции которая возвращает промис \n// То есть  благодаря этому после выполнения \n// этой функции мы можем выстраивать цепочку \n// событий которые произойдут после ее выполнения\nconst sleep = ms => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(), ms)\n  })\n}\n\nsleep(2000).then(() => console.log('After 2 sec'))\nsleep(3000).then(() => console.log('After 3 sec'))\n```\n\n# Глобальные обработчик промисов \nЯ назвал их глобальными потому что они могут обслучживать несолько промисов.\nИх объединяет то что они оба принимают в себя массив из функций котрые возвращают промисы. только __Promise.all__ начинает выполнять цепочку событий только после того как выполнятся все промисы а __Promise.race__ начинает после первого завершившегося.\n``` js\nPromise.all([sleep(2000), sleep(3000)]).then(() => {\n  console.log('All promises')\n})\n\nPromise.race([sleep(2000), sleep(3000)]).then(() => {\n  console.log('Race promises')\n})\n```",
        "message": "",
        "created": "2021-09-04T12:59:55.569Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "2f63e4b0-bd48-4386-adc8-dbf50badb3d5",
      "emoji": null,
      "title": "Переименование нескольких фалов одновременно",
      "content": "",
      "headId": 1114075,
      "archivedAt": null,
      "folderPathname": "/Общее решения",
      "parentFolderId": "1b0abfc2-935b-4ae6-a795-8ab1af7ab6d8",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-03T05:46:42.541Z",
      "updatedAt": "2021-09-03T05:49:07.529Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1114075,
        "docId": "2f63e4b0-bd48-4386-adc8-dbf50badb3d5",
        "content": "Утилита rename переименовывает данные файлы, заменяя первое выражение в их имени заменой.\n\nКоманда rename устанавливается в большинстве Unix-подобных операционных систем.\n\nЕсли он по умолчанию недоступен, выполните следующую команду, чтобы установить его в системах на базе Debian:\n```\n$ sudo apt install rename\n```\nНапример, у меня есть следующие файлы в текущем каталоге.\n```\n$ ls\n```\nabcd1.txt abcd2.txt abcd3.txt\nЗаменим первое  abc на xyz, где бы оно ни находилось. Для этого запустите:\n\n```\n$ rename 's/abc/xyz/' *\n```\n\nТеперь проверьте, были ли сделаны изменения с помощью команды ls.\n\n```\n$ ls xyzd1.txt xyzd2.txt xyzd3.txt\n```\n\nИногда вы можете просто вывести выходные данные вместо переименования файлов.\n\nЕсли это так, используйте флаг -n для отображения тех переименований, которые будут выполняться без их выполнения:\n\n```\n$ rename -n 's/abc/xyz/' *\nrename(abcd1.txt, xyzd1.txt)\nrename(abcd2.txt, xyzd2.txt)\nrename(abcd3.txt, xyzd3.txt)\n```\n\nКак вы можете видеть, приведенная выше команда не вносила никаких изменений, а просто отображает имена переименованных файлов.\n\nВы можете принудительно переименовать задачу, даже если операция будет перезаписывать существующие файлы с использованием флага -f, как показано ниже.\n\n```\n$ rename -f 's/abc/xyz/' *\n```\n\nЕсли вы не хотите перезаписывать файлы, вы можете просто преобразовать их в заглавные или строчные буквы (и наоборот), чтобы предотвратить «уже существующие» ошибки.\n\nЧтобы преобразовать все имена файлов в нижний регистр:\n```\n$ rename 'y/a-z/A-Z/' *\n```\nДавайте проверим, были ли внесены изменения.\n```\n$ ls ABCD1.TXT ABCD2.TXT ABCD3.TXT\n```\nДа, буквы в именах файлов были изменены с нижнего регистра на верхний регистр.\n\nАналогично, чтобы преобразовать имена файлов в нижний регистр, выполните:\n```\n$ rename 'y/A-Z/a-z/' *\n```\nМы также можем удалить все пустые ячейки в имени файла.\n\nНапример, у меня есть следующий файл.\n```\n$ ls Clouds of Sunset.mp3\n```\nЧтобы удалить все пробелы в указанном выше имени файла, запустите:\n```\n$ rename \"s/ *//g\" *\n```\nТеперь имя файла не имеет пробелов.\n```\n$ ls CloudsofSunset.mp3\n```\nЗаменить пробелы символами подчеркивания:\n```\n$ rename 's/\\s+/_/g' *\n```\nВозможно, вы захотите изменить расширение файла, но не переименовать имена файлов.\n\nЭто также возможно.\n\nСледующая команда переименовала бы все * .txt-файлы в * .doc.\n```\n$ rename 's/\\.txt$/.doc/' *.txt\n```\nПроверьте изменения с помощью команды ls:\n```\n$ ls abcd1.doc abcd2.doc abcd3.doc\n```\nЧтобы удалить расширение во всех файлах, соответствующих .txt, запустите:\n```\n$ rename 's/\\.txt$//' *.txt\n```\nДля получения дополнительной информации см. Справочные страницы.\n```\n$ man rename\n```",
        "message": "",
        "created": "2021-09-03T05:49:07.518Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    },
    {
      "id": "12f3094b-9eb4-4c78-bf9c-4e8ae8ecb70e",
      "emoji": null,
      "title": "Супер асинхронные опирации с запросами (и мутациями)",
      "content": "",
      "headId": 1110514,
      "archivedAt": null,
      "folderPathname": "/React/Apollo",
      "parentFolderId": "917eb315-1d9e-4a59-8923-1813b06e6ef5",
      "teamId": "nhFMY3a5g",
      "generated": false,
      "createdAt": "2021-09-02T12:43:15.416Z",
      "updatedAt": "2021-09-02T12:47:41.639Z",
      "version": 2,
      "userId": "b0568c88-bb34-4420-969e-41238089a0d4",
      "workspaceId": "4ae225f9-123d-4918-a49f-e0c91bd0b18a",
      "head": {
        "id": 1110514,
        "docId": "12f3094b-9eb4-4c78-bf9c-4e8ae8ecb70e",
        "content": "Здесь оисан пример как можно взаимодействовать с apollo клиентом и в асинхронном ключе выполнять различные операции. Тут в приимере ест и условия и промис в промисе что дает огромное пространство в проработке сценариев развитея после запроса. Тут даже можно после запроса сделать еще один запрос и проработать его сценарии что есть очень круто.\n\n``` js\nconst ShopifyHmac:FC = () => {\n  const client = useApolloClient();\n  const [req, setReq] = useState('');\n  const query = useQuery();\n  const history = useHistory();\n\nconst sendQuery = async (req: string) => {\n    const result = await client.query({\n      query: SEND_QUERY,\n      variables: { req: req },\n    })\n      .then(result => result.data)\n      .then(data => {\n        if(data.shopifyHmac.url){\n          window.location.href = data.shopifyHmac.url\n        } else {\n          localStorage.setItem('access_token', data.shopifyHmac.authTokens.accessToken)\n          client.query({\n            query: GET_USER\n          }).then(\n            () => history.push('/dashboard')\n          )\n        }\n      })\n      .catch(e => console.log(e));\n    // console.log('ShopifyHmac', data)\n  }\n",
        "message": "",
        "created": "2021-09-02T12:47:41.617Z",
        "creators": [
          {
            "id": "b0568c88-bb34-4420-969e-41238089a0d4",
            "uniqueName": "google#113467622262670857280",
            "displayName": "Alexander Matviienko",
            "createdAt": "2021-05-10T19:50:11.968Z",
            "updatedAt": "2021-05-10T19:50:31.732Z"
          }
        ]
      }
    }
  ]
}